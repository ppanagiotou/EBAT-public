# Name = rules.conf;;;
# Comments with hash symbol (#)
# Rules
# unique id ;  description
# 0; DEPENDED, (mainly for predecessors)

# 1; Symmetric Key Encryption
#  11; constant key
#  12; constant iv
#  13; using ecb mode
#  14; constant input
#  15; Weak cipher
#  16; padding mode

# 2; Authenticated Encryption, MAC based on block ciphers, authenticated encryption with associated data (AEAD)
#  21; constant key
#  22; constant iv
#  23; constant input
#  24; constant AAD
#  25; constant Authentication Tag

# 3: Public Key Cryptography
#   31; RSA Padding
#   32; RSA Weak Padding
#   33; X509 Digest function
#   34; X509 Weak Digest function
#   35; Digital Signatures digest function
#   36; Digital Signature weak digest function
#   37; RSA exponent (e)
#   38; RSA constant private key (d)
#   39; Public key encrypt/decrypt constant input

# 40; EXTRA TAINT ARGUMENTS -> DEBUG FOR NOW
# 41; SSL_TLS_CIPHER_SUITES -> DEBUG

# 6; Pseudorandom number generators
#  61; WEAK PRNGs
#  62; using static seed for PRF
#  63: Possible weak entropy seed

# 7; Hash Functions Keyed (MAC based on hash functions)
#  71; Constant hash input
#  72; Constant key
#  73; Weak underlying hash function
#  74; Usage of short key size

# 8; Hash Functions unkeyed
#  81; Constant hash input
#  82; Weak hash function

# 9; KDFs and Password Hash
#  91; Constant keys
#  92; Constant salts
#  93; Iterations
#  94; Weak Iterations
#  95; Weak underlying crypto function

# Tainted functions
# name; signature; number of parameters; rule type; [rule:taint parameter ID:type];
# priorities in the form of 1<2, meaing argument 1 has higher priority than 2, then it needs to resolve them first
# taint parameters = 0 -> if you dont want to taint a parameter;;; (function is tainted instead)
# 1:type:0 -> apply rule 0, with taint parameter 1 , type of the parameter must declared (possible types int, string etc );;;
# 1:type1:7; 2:type2:8 -> if you want to taint multiple parameters;;

# CTX = context
# CTYPE = cipher type use for all ciphers, hash, etc as thunk functions
# bit = size in bits
# byte = size in bytes
# bytes = byte array
# string = character array
# int = integer constant
# output = possibly a pointer to which output is saved


# ---------------------------------------------------------------------------------------------------------------------------- #

# ---------------------------------------------------------------------------------------------------------------------------- #
# ------------------------------------------ Symmetric Key Encryption -------------------------------------------------------- #
# ---------------------------------------------------------------------------------------------------------------------------- #

# TODO (FUTURE): taint to see the use in crypto keys, iv arguments
# int memcmp ( const void * ptr1, const void * ptr2, size_t num );
# memcpy; void memcpy(); 2; 0; 0; 1:bytes:0; 2:bytes:0; 3:int:0; 3<2;

#libgcrypt;;;
gcry_cipher_open; gcry_error_t gcry_cipher_open (gcry_cipher_hd_t *hd, int algo, int mode, unsigned int flags);4; 1; 1:CTX:1; 2:CTYPE:1; 3:CTYPE:1; 4:CTYPE:40;
gcry_cipher_setiv; gcry_error_t gcry_cipher_setiv(gcry_cipher_hd_t h, const void *k, size_t l);3; 1; 1:CTX:1; 2:bytes:12; 3:byte:0; 3<2
# for counter in CTR mode of operation
gcry_cipher_setctr; gcry_error_t gcry_cipher_setctr (gcry_cipher_hd_t h, const void *c, size_t l);3; 1; 1:CTX:1; 2:bytes:12; 3:byte:0; 3<2
gcry_cipher_setkey; gcry_error_t gcry_cipher_setkey (gcry_cipher_hd_t h, const void *k, size_t l);3; 1; 1:CTX:1; 2:bytes:11; 3:byte:0; 3<2
gcry_cipher_encrypt; gcry_error_t gcry_cipher_encrypt (gcry_cipher_hd_t h, unsigned char *out, size_t outsize, const unsigned char *in, size_t inlen);5; 1; 1:CTX:1; 2:output:1; 4:bytes:14; 5:byte:0; 5<4;
gcry_cipher_decrypt; gcry_error_t gcry_cipher_decrypt (gcry_cipher_hd_t h, unsigned char *out, size_t outsize, const unsigned char *in, size_t inlen);5; 1; 1:CTX:1; 2:output:1; 4:bytes:14; 5:byte:0; 5<4;
# extra control arguments
# may used in authenticated encryption too
gcry_cipher_ctl; gcry_error_t gcry_cipher_ctl (gcry_cipher_hd_t h, int cmd, void *buffer, size_t buflen);4; 1; 1:CTX:1; 2:type:40; 3:arg:40; 4:byte:0; 1<2; 1<3; 4<3

# AES
#libcrypto;;;
AES_set_encrypt_key; int AES_set_encrypt_key(const unsigned char *userKey, const int bits,AES_KEY *key);3; 1; 1:bytes=16=24=32:11; 2:bit:0; 2<1; 3:output:1;
AES_set_decrypt_key; int AES_set_decrypt_key (const unsigned char *userKey, const int bits, AES_KEY *key);3; 1; 1:bytes=16=24=32:11; 2:bit:0; 2<1; 3:output:1;
AES_ecb_encrypt; void AES_ecb_encrypt (const unsigned char *in, unsigned char *out, const AES_KEY *key, const int enc);4; 1; 1:bytes=16:14; 2:output:1; 0:none:13; 4:int:1; 3:CTX:1;

AES_cbc_encrypt; void AES_cbc_encrypt (const unsigned char *in, unsigned char *out, size_t length, const AES_KEY *key, unsigned char *ivec, const int enc);6; 1; 1:bytes:14; 2:output:1; 3:int:0; 3<1; 4:CTX:1; 5:bytes=16:12; 6:int:1
AES_cfb128_encrypt; void AES_cfb128_encrypt (const unsigned char *in, unsigned char *out, size_t length, const AES_KEY *key, unsigned char *ivec, int *num, const int enc);7; 1; 1:bytes:14; 2:output:1; 3:int:0; 3<1; 5:bytes=16:12; 7:int:1
AES_cfb1_encrypt; void AES_cfb1_encrypt (const unsigned char *in, unsigned char *out, size_t length, const AES_KEY *key, unsigned char *ivec, int *num, const int enc);7; 1; 1:bytes:14; 2:output:1; 3:int:0; 3<1; 5:bytes=16:12; 7:int:1
AES_cfb8_encrypt; void AES_cfb8_encrypt (const unsigned char *in, unsigned char *out, size_t length, const AES_KEY *key, unsigned char *ivec, int *num, const int enc);7; 1; 1:bytes:14; 2:output:1; 3:int:0; 3<1; 5:bytes=16:12; 7:int:1
AES_ofb128_encrypt; void AES_ofb128_encrypt (const unsigned char *in, unsigned char *out, size_t length, const AES_KEY *key, unsigned char *ivec, int *num);6; 1; 1:bytes:14; 2:output:1; 3:int:0; 3<1; 5:bytes=16:12;
AES_wrap_key; int AES_wrap_key (AES_KEY *key, const unsigned char *iv, unsigned char *out, const unsigned char *in, unsigned int inlen);5; 1; 1:CTX:1; 2:output:1; 2:bytes=16:12; 4:bytes=16=24=32:11; 5:byte:0; 5<4
AES_unwrap_key; int AES_unwrap_key (AES_KEY *key, const unsigned char *iv, unsigned char *out, const unsigned char *in, unsigned int inlen);5; 1; 1:CTX:1; 2:bytes=16:12; 4:bytes=16=24=32:11; 5:byte:0; 5<4
AES_ctr128_encrypt; void AES_ctr128_encrypt(const unsigned char *in, unsigned char *out, size_t length, const AES_KEY *key, unsigned char ivec[AES_BLOCK_SIZE],unsigned char ecount_buf[AES_BLOCK_SIZE],unsigned int *num); 7;1; 1:bytes:14; 2:output:1; 3:byte:0; 4:CTX:1; 3<1; 5:bytes=16:12;

# low level
CRYPTO_cfb128_1_encrypt; void CRYPTO_cfb128_1_encrypt(const unsigned char *in, unsigned char *out, size_t bits, const void *key, unsigned char ivec[16], int *num, int enc, block128_f block);8; 1; 1:bytes:14; 2:output:1; 3:bit:0; 3<1; 5:bytes=16:12; 4:bytes=16:11; 7:int:1
CRYPTO_cfb128_8_encrypt;void CRYPTO_cfb128_8_encrypt(const unsigned char *in, unsigned char *out,size_t length, const void *key, unsigned char ivec[16], int *num, int enc, block128_f block);8; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 5:bytes=16:12; 4:bytes=16:11; 7:int:1
CRYPTO_cfb128_encrypt; void CRYPTO_cfb128_encrypt(const unsigned char *in, unsigned char *out, size_t len, const void *key, unsigned char ivec[16], int *num, int enc, block128_f block);8; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 5:bytes=16:12; 4:bytes=16:11; 7:int:1

# encrypt/decrypts a single block
AES_encrypt; void AES_encrypt(const unsigned char *in, unsigned char *out, const AES_KEY *key);3; 1; 1:bytes=16:14; 2:output:1; 0:none:13; 3:CTX:1;
AES_decrypt; void AES_decrypt(const unsigned char *in, unsigned char *out, const AES_KEY *key);3; 1; 1:bytes=16:14; 2:output:1; 0:none:13; 3:CTX:1;

# Blowfish
BF_set_key; void BF_set_key(BF_KEY *key, int len, const unsigned char *data);3; 1; 1:output:1; 3:bytes=16=24=32=56:11; 2:byte:0; 2<3
BF_ecb_encrypt; void BF_ecb_encrypt(const unsigned char *in, unsigned char *out,BF_KEY *key, int enc);4; 1; 1:bytes=8:14; 0:none:13; 3:CTX:1; 4:int:1
BF_cbc_encrypt; void BF_cbc_encrypt(const unsigned char *in, unsigned char *out,long length, BF_KEY *schedule, unsigned char *ivec, int enc);6; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 5:bytes=8:12; 6:int:1
BF_cfb64_encrypt; void BF_cfb64_encrypt(const unsigned char *in, unsigned char *out,long length, BF_KEY *schedule, unsigned char *ivec, int *num,int enc);7; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 5:string:12; 7:int:1
BF_ofb64_encrypt; void BF_ofb64_encrypt(const unsigned char *in, unsigned char *out,long length, BF_KEY *schedule, unsigned char *ivec, int *num);6; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 5:string:12;
# encrypt/decrypts a single block
BF_encrypt; void BF_encrypt(BF_LONG *data,const BF_KEY *key);2; 1; 1:bytes=8:14; 2:bytes=8:11; 0:none:13;
BF_decrypt; void BF_decrypt(BF_LONG *data,const BF_KEY *key);2; 1; 1:bytes=8:14; 2:bytes=8:11; 0:none:13;

# Camellia
Camellia_set_key; int Camellia_set_key(const unsigned char *userKey, const int bits, CAMELLIA_KEY *key);3; 1; 1:bytes=16=24=32:11; 2:bit:0; 2<1; 3:output:1;
Camellia_ecb_encrypt; void Camellia_ecb_encrypt(const unsigned char *in, unsigned char *out, const CAMELLIA_KEY *key, const int enc);4; 1; 1:bytes=16:14; 2:output:1; 0:none:13; 4:int:1;
Camellia_cbc_encrypt; void Camellia_cbc_encrypt(const unsigned char *in, unsigned char *out, size_t length, const CAMELLIA_KEY *key, unsigned char *ivec, const int enc);6; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<2; 5:bytes=16:12; 6:int:1
Camellia_cfb128_encrypt; void Camellia_cfb128_encrypt(const unsigned char *in, unsigned char *out, size_t length, const CAMELLIA_KEY *key, unsigned char *ivec, int *num, const int enc);7; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<2; 5:bytes=16:12; 7:int:1
Camellia_cfb1_encrypt; void Camellia_cfb1_encrypt(const unsigned char *in, unsigned char *out, size_t length, const CAMELLIA_KEY *key, unsigned char *ivec, int *num, const int enc);7; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<2; 5:bytes=16:12; 7:int:1
Camellia_cfb8_encrypt; void Camellia_cfb8_encrypt(const unsigned char *in, unsigned char *out, size_t length, const CAMELLIA_KEY *key, unsigned char *ivec, int *num, const int enc);7; 1; 1:bytes:14; 3:byte:0; 3<2; 5:bytes=16:12; 7:int:1
Camellia_ofb128_encrypt; void Camellia_ofb128_encrypt(const unsigned char *in, unsigned char *out, size_t length, const CAMELLIA_KEY *key, unsigned char *ivec, int *num);6; 1; 1:bytes:14; 3:byte:0; 3<2; 5:bytes=16:12;
Camellia_encrypt; void Camellia_encrypt (const unsigned char *in, unsigned char *out, const CAMELLIA_KEY *key);3; 1; 1:bytes=16:14; 2:output:1; 3:CTX:1;
Camellia_decrypt; void Camellia_decrypt (const unsigned char *in, unsigned char *out, const CAMELLIA_KEY *key);3; 1; 1:bytes=16:14; 2:output:1; 3:CTX:1;


# CAST
CAST_ecb_encrypt; void CAST_ecb_encrypt(const unsigned char *in, unsigned char *out, const CAST_KEY *key, int enc);4; 1; 1:bytes=16:14; 2:output:1; 0:none:13; 4:int:1; 4:CTX:1;
CAST_encrypt; void CAST_encrypt(CAST_LONG *data, const CAST_KEY *key);2; 1; 1:bytes=16:14; 2:output:1; 0:none:13;
CAST_decrypt; void CAST_decrypt(CAST_LONG *data, const CAST_KEY *key);2; 1; 1:bytes=16:14; 2:output:1; 0:none:13;
CAST_set_key; void CAST_set_key(CAST_KEY *key, int len, const unsigned char *data);3; 1; 3:bytes=16=24=32:11; 2:byte:0; 2<1; 1:output:1;
CAST_cbc_encrypt; void CAST_cbc_encrypt(const unsigned char *in, unsigned char *out, long length, const CAST_KEY *ks, unsigned char *iv, int enc);6; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 5:bytes=16:12; 6:int:1
CAST_cfb64_encrypt; void CAST_cfb64_encrypt(const unsigned char *in, unsigned char *out, long length, const CAST_KEY *schedule, unsigned char *ivec, int *num, int enc);7; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 5:bytes=16:12; 7:int:1
CAST_ofb64_encrypt; void CAST_ofb64_encrypt(const unsigned char *in, unsigned char *out, long length, const CAST_KEY *schedule, unsigned char *ivec, int *num);6; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 5:bytes=16:12;

# DES
# https://www.openssl.org/docs/man1.1.0/man3/DES_random_key.html
DES_cfb_encrypt; void DES_cfb_encrypt(const unsigned char *in, unsigned char *out,int numbits, long length, DES_key_schedule *schedule,DES_cblock *ivec, int enc);7; 1; 1:bytes:14; 2:output:1; 3:int:40; 4:byte:0; 4<1; 6:bytes=8:12; 7:int:1;
DES_ofb_encrypt; void DES_ofb_encrypt(const unsigned char *in, unsigned char *out,int numbits, long length, DES_key_schedule *schedule,DES_cblock *ivec);6; 1; 1:bytes:14; 2:output:1; 3:int:40; 4:byte:0; 4<1; 6:bytes=8:12;
DES_pcbc_encrypt; void DES_pcbc_encrypt(const unsigned char *input, unsigned char *output,long length, DES_key_schedule *schedule, DES_cblock *ivec,int enc);6; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 5:bytes=8:12; 6:int:1;
DES_cfb64_encrypt; void DES_cfb64_encrypt(const unsigned char *in, unsigned char *out,long length, DES_key_schedule *schedule, DES_cblock *ivec,int *num, int enc);7; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 5:bytes=8:12; 7:int:1
DES_ofb64_encrypt; void DES_ofb64_encrypt(const unsigned char *in, unsigned char *out,long length, DES_key_schedule *schedule, DES_cblock *ivec,int *num);6; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 5:bytes=8:12;
DES_xcbc_encrypt; void DES_xcbc_encrypt(const unsigned char *input, unsigned char *output, long length, DES_key_schedule *schedule, DES_cblock *ivec, const_DES_cblock *inw, const_DES_cblock *outw, int enc);8; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 5:bytes=8:12; 8:int:1
DES_ede2_cbc_encrypt; void DES_ede2_cbc_encrypt(const unsigned char *input, unsigned char *output, long length, DES_key_schedule *ks1,DES_key_schedule *ks2, DES_cblock *ivec, int enc);7; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 6:bytes=8:12; 7:int:1
DES_ede2_cfb64_encrypt; void DES_ede2_cfb64_encrypt(const unsigned char *in,unsigned char *out, long length, DES_key_schedule *ks1,DES_key_schedule *ks2, DES_cblock *ivec, int *num, int enc);8; 1;  2:output:1; 3:byte:0; 3<1; 1:bytes:14; 6:bytes=8:12; 8:int:1
DES_ede2_ofb64_encrypt; void DES_ede2_ofb64_encrypt(const unsigned char *in,unsigned char *out, long length, DES_key_schedule *ks1,DES_key_schedule *ks2, DES_cblock *ivec, int *num);7; 1; 1:bytes:14;  2:output:1; 3:byte:0; 3<1; 6:bytes=8:12;
DES_ede3_cbc_encrypt; void DES_ede3_cbc_encrypt(const unsigned char *input,unsigned char *output, long length, DES_key_schedule *ks1,DES_key_schedule *ks2, DES_key_schedule *ks3, DES_cblock *ivec,int enc);8;1; 1:bytes=8:14; 2:output:1; 3:byte:0; 3<1; 7:bytes=8:12; 8:int:1
des_ede3_cbc_encrypt; void des_ede3_cbc_encrypt(const unsigned char *input,unsigned char *output, long length, DES_key_schedule *ks1,DES_key_schedule *ks2, DES_key_schedule *ks3, DES_cblock *ivec,int enc);8;1; 1:bytes=8:14; 2:output:1; 3:byte:0; 3<1; 7:bytes=8:12; 8:int:1
DES_ede3_cfb64_encrypt; void DES_ede3_cfb64_encrypt(const unsigned char *in, unsigned char *out,long length, DES_key_schedule *ks1, DES_key_schedule *ks2,DES_key_schedule *ks3, DES_cblock *ivec, int *num, int enc);9; 1; 1:bytes=8:14; 2:output:1; 3:byte:0; 3<1; 7:bytes=8:12; 9:int:1
DES_ede3_ofb64_encrypt; void DES_ede3_ofb64_encrypt(const unsigned char *in, unsigned char *out,long length, DES_key_schedule *ks1,DES_key_schedule *ks2, DES_key_schedule *ks3,DES_cblock *ivec, int *num);8; 1; 7:bytes=8:12; 1:bytes=8:14; 2:output:1; 3:byte:0; 3<1;
DES_cbc_encrypt; void DES_cbc_encrypt (const void *in, void *out, long length, DES_key_schedule *ks, DES_cblock *iv, int encp); 6;1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 4:bytes=8:12; 5:bytes=8:11; 6:int:1;
des_cbc_encrypt; void des_cbc_encrypt (const void *in, void *out, long length, DES_key_schedule *ks, DES_cblock *iv, int encp); 6;1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 4:bytes=8:12; 5:bytes=8:11; 6:int:1;


DES_ncbc_encrypt; void DES_ncbc_encrypt(const unsigned char *input, unsigned char *output,long length, DES_key_schedule *schedule, DES_cblock *ivec,int enc);6; 1; 1:bytes:14; 3:byte:0; 3<1; 5:bytes:12; 2:output:1; 6:int:1
des_ncbc_encrypt; void des_ncbc_encrypt(const unsigned char *in, unsigned char *out, long length, des_key_schedule schedule, des_cblock *ivec, int enc);6; 1; 1:bytes:14; 3:byte:0; 3<1; 5:bytes:12; 2:output:1; 6:int:1;

# ---------------------------------
# Using DES with 56 bits key (classical)
DES_ecb_encrypt; void DES_ecb_encrypt(const_DES_cblock *input, DES_cblock *output,DES_key_schedule *ks, int enc);4; 1; 0:none:13; 1:bytes=8:14; 4:int:1
# Using 3-DES with 2 keys
DES_ecb2_encrypt; void DES_ecb2_encrypt(const_DES_cblock *input, DES_cblock *output,DES_key_schedule *ks1, DES_key_schedule *ks2, int enc);5; 1; 0:none:13; 1:bytes=8:14; 5:int:1
# using 3-DES with 3 keys
DES_ecb3_encrypt; void DES_ecb3_encrypt(const_DES_cblock *input, DES_cblock *output,DES_key_schedule *ks1, DES_key_schedule *ks2, DES_key_schedule *ks3, int enc);6; 1; 0:none:13; 1:bytes=8:14; 6:int:1


DES_encrypt1; void 	DES_encrypt1 (DES_LONG *data, DES_key_schedule *ks, int enc);3 ;1; 1:bytes=8:14; 3:int:1; 0:none:13;
DES_encrypt2; void 	DES_encrypt2 (DES_LONG *data, DES_key_schedule *ks, int enc);3 ;1; 1:bytes=8:14; 3:int:1; 0:none:13;
DES_encrypt3; void 	DES_encrypt3 (DES_LONG *data, DES_key_schedule *ks1, DES_key_schedule *ks2, DES_key_schedule *ks3);4;1; 1:bytes=8:14; 0:none:13;
DES_decrypt3; void 	DES_decrypt3 (DES_LONG *data, DES_key_schedule *ks1, DES_key_schedule *ks2, DES_key_schedule *ks3);4;1; 1:bytes=8:14; 0:none:13;

# RC2
RC2_set_key; void RC2_set_key (RC2_KEY *key, int len, const unsigned char *data, int bits);4; 1; 1:CTX:1; 3:bytes:11; 2:byte:0; 2<3; 4:int:40;
RC2_ecb_encrypt; void RC2_ecb_encrypt(const unsigned char *in, unsigned char *out, RC2_KEY *key, int enc);4; 1; 1:bytes=8:14; 2:output:1; 0:none:13; 4:int:1
RC2_encrypt; void RC2_encrypt(unsigned long *data, RC2_KEY *key);2; 1; 1:bytes=8:14; 0:none:13;
RC2_decrypt; void RC2_decrypt(unsigned long *data, RC2_KEY *key);2; 1; 1:bytes=8:14; 0:none:13;
RC2_cbc_encrypt; void RC2_cbc_encrypt(const unsigned char *in, unsigned char *out, long length, RC2_KEY *ks, unsigned char *iv, int enc);6; 1; 1:bytes=8:14; 3:byte:0; 3<1; 5:bytes=8:12; 6:int:1
RC2_cfb64_encrypt; void RC2_cfb64_encrypt(const unsigned char *in, unsigned char *out, long length, RC2_KEY *schedule, unsigned char *ivec, int *num, int enc);7; 1; 1:bytes=8:14; 3:byte:0; 3<1; 5:bytes=8:12; 7:int:1
RC2_ofb64_encrypt; void RC2_ofb64_encrypt(const unsigned char *in, unsigned char *out, long length, RC2_KEY *schedule, unsigned char *ivec, int *num);6; 1; 1:bytes=8:14; 3:byte:0; 3<1; 5:bytes=8:12

# General
EVP_CipherInit; int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type, unsigned char *key, unsigned char *iv, int enc);5; 1; 1:CTX:1; 2:CTYPE:1; 3:bytes=16:11; 4:bytes=16:12; 6:int:1; 2<3; 2<4; 5:int:1
WolfSSL_EVP_CipherInit; int WolfSSL_EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type, unsigned char *key, unsigned char *iv, int enc);5; 1; 1:CTX:1; 2:CTYPE:1; 3:bytes=16:11; 4:bytes=16:12; 6:int:1; 2<3; 2<4; 5:int:1
EVP_DecryptInit; int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type, unsigned char *key, unsigned char *iv);4; 1; 1:CTX:1; 2:CTYPE:1; 3:bytes=16:11; 4:bytes=16:12; 2<3; 2<4
EVP_EncryptInit; int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type, unsigned char *key, unsigned char *iv);4; 1; 1:CTX:1; 2:CTYPE:1; 3:bytes=16:11; 4:bytes=16:12; 2<3; 2<4
EVP_CipherInit_ex; int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type, ENGINE *impl, unsigned char *key, unsigned char *iv, int enc);6; 1; 1:CTX:1; 2:CTYPE:1; 4:bytes=16:11; 5:bytes=16:12; 2<4; 2<5; 6:int:1
EVP_DecryptInit_ex; int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type, ENGINE *impl, unsigned char *key, unsigned char *iv);5; 1; 1:CTX:1; 2:CTYPE:1; 4:bytes=16:11; 5:bytes=16:12; 2<4; 2<5;
EVP_EncryptInit_ex; int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type, ENGINE *impl, unsigned char *key, unsigned char *iv);5; 1; 1:CTX:1; 2:CTYPE:1; 4:bytes=16:11; 5:bytes=16:12; 2<4; 2<5
EVP_EncryptUpdate; int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl, const unsigned char *in, int inl);5; 1; 1:CTX:1; 4:bytes:14; 5:byte:0; 5<4;
EVP_DecryptUpdate; int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl, const unsigned char *in, int inl);5; 1; 1:CTX:1; 4:bytes:14; 5:byte:0; 5<4;
EVP_CipherUpdate; int EVP_CipherUpdate(EVP_CIPHER_CTX * ctx, uchar * out, int * outl, uchar * in, int inl);5; 1; 1:CTX:1; 4:bytes:14; 5:byte:0; 5<4;

EVP_DecryptFinal; int EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl); 3; 1; 1:CTX:1; 2:output:1;
EVP_DecryptFinal_ex; int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl); 3; 1; 1:CTX:1; 2:output:1;
EVP_EncryptFinal; int EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl); 3; 1; 1:CTX:1; 2:output:1;
EVP_EncryptFinal_ex; int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl); 3; 1; 1:CTX:1; 2:output:1;

EVP_CIPHER_CTX_ctrl; int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);4; 1; 1:CTX:1; 2:type:40; 3:arg:40; 1<2; 1<3;
EVP_get_cipherbyname; const EVP_CIPHER *EVP_get_cipherbyname(const char *name);1; 1; 1:string:40;

# Problem with des maybe leakkeys
# DES_string_to_key() is available for backward compatibility with the MIT library.
# New applications should use a cryptographic hash function. The same applies for DES_string_to_2key().
DES_string_to_2keys; void DES_string_to_2keys(const char *str, DES_cblock *key1,DES_cblock *key2);3; 1; 1:string:11
DES_string_to_key; void DES_string_to_key(const char *str, DES_cblock *key); 2; 1; 1:string:11

#wolfcrypt;;;:
# AES
wc_AesSetKey; int wc_AesSetKey(Aes *aes, const byte *key, word32 len, const byte *iv, int dir);5; 1; 1:CTX:1; 2:bytes=16=24=32:11; 3:byte:0; 3<2; 4:bytes=16:12; 5:int:1;
wc_AesSetIV; int wc_AesSetIV(Aes *aes, const byte *iv);2; 1; 1:CTX:1; 2:bytes=16:12;
wc_AesEncryptDirect; void wc_AesEncryptDirect(Aes *aes, byte *out, const byte *in);3; 1; 1:CTX:1; 2:output:1; 3:bytes=16:14;
wc_AesDecryptDirect; void wc_AesDecryptDirect(Aes *aes, byte *out, const byte *in);3; 1; 1:CTX:1; 2:output:1; 3:bytes=16:14;
wc_AesSetKeyDirect; int wc_AesSetKeyDirect (Aes *aes, const byte *key, word32 len, const byte *iv, int dir);5; 1; 1:CTX:1; 2:bytes=16=24=32:11; 3:byte:0; 3<2; 4:bytes=16:12; 5:int:1;

wc_AesCbcEncrypt; int wc_AesCbcEncrypt (Aes *aes, byte *out, const byte *in, word32 sz); 4; 1; 1:CTX:1; 2:output:1; 3:bytes:14; 4:byte:0; 4<3;
wc_AesCbcDecrypt; int wc_AesCbcDecrypt (Aes *aes, byte *out, const byte *in, word32 sz); 4; 1; 1:CTX:1; 2:output:1; 3:bytes:14; 4:byte:0; 4<3;

# Camellia
wc_CamelliaSetKey; int wc_CamelliaSetKey (Camellia *cam, const byte *key, word32 len, const byte *iv);4; 1; 1:CTX:1; 2:bytes=16=24=32:11; 3:byte:0; 3<2; 4:bytes=16:12;
wc_CamelliaSetIV; int wc_CamelliaSetIV (Camellia *cam, const byte *iv);2; 1; 1:CTX:1; 2:bytes=16:12;
wc_CamelliaEncryptDirect; int wc_CamelliaEncryptDirect (Camellia *cam, byte *out, const byte *in);3; 1; 1:CTX:1; 2:output:1; 3:bytes=16:14;
wc_CamelliaDecryptDirect; int wc_CamelliaDecryptDirect (Camellia *cam, byte *out, const byte *in);3; 1; 1:CTX:1; 2:output:1; 3:bytes=16:14;
wc_CamelliaCbcEncrypt; int 	wc_CamelliaCbcEncrypt (Camellia *cam, byte *out, const byte *in, word32 sz);3; 1; 1:CTX:1; 2:output:1; 3:bytes:14; 4:byte:0; 4<3
wc_CamelliaCbcDecrypt; int 	wc_CamelliaCbcDecrypt (Camellia *cam, byte *out, const byte *in, word32 sz);3; 1; 1:CTX:1; 2:output:1; 3:bytes:14; 4:byte:0; 4<3
# DES
wc_Des_SetKey; int wc_Des_SetKey (Des *des, const byte *key, const byte *iv, int dir);4; 1; 1:CTX:1; 2:bytes=8:11; 3:bytes=8:12; 4:int:1;
wc_Des_SetIV; void wc_Des_SetIV (Des *des, const byte *iv);2; 1; 1:CTX:1; 2:bytes=8:12;
wc_Des_EcbEncrypt; int wc_Des_EcbEncrypt (Des *des, byte *out, const byte *in, word32 sz);4; 1; 1:CTX:1; 2:output:1; 3:bytes:14; 4:byte:0; 4<3; 0:none:13;
wc_Des3_EcbEncrypt; int wc_Des3_EcbEncrypt (Des3 *des, byte *out, const byte *in, word32 sz);4; 1; 1:CTX:1; 2:output:1; 3:bytes:14; 4:byte:0; 4<3; 0:none:13;
wc_Des3_SetKey; int wc_Des3_SetKey (Des3 *des, const byte *key, const byte *iv, int dir);4; 1; 1:CTX:1; 2:bytes=24:11; 3:bytes=8:12; 4:int:1;
wc_Des3_SetIV; int wc_Des3_SetIV (Des3 *des, const byte *iv);2; 1; 1:CTX:1; 2:bytes=8:12;
wc_Des_CbcDecryptWithKey; int wc_Des_CbcDecryptWithKey (byte *out, const byte *in, word32 sz, const byte *key, const byte *iv);5; 1; 1:output:1; 2:bytes:14; 3:byte:0; 3<2; 4:bytes=8:11; 5:bytes=8:12;
wc_Des_CbcEncryptWithKey; int wc_Des_CbcEncryptWithKey (byte *out, const byte *in, word32 sz, const byte *key, const byte *iv);5; 1; 1:output:1; 2:bytes:14; 3:byte:0; 3<2; 4:bytes=8:11; 5:bytes=8:12;
wc_Des3_CbcEncryptWithKey; int wc_Des3_CbcEncryptWithKey (byte *out, const byte *in, word32 sz, const byte *key, const byte *iv);5; 1; 1:output:1; 2:bytes:14; 3:byte:0; 3<2; 4:bytes=24:11; 5:bytes=8:12;
wc_Des3_CbcDecryptWithKey; int wc_Des3_CbcDecryptWithKey (byte *out, const byte *in, word32 sz, const byte *key, const byte *iv);5; 1; 1:output:1; 2:bytes:14; 3:byte:0; 3<2; 4:bytes=24:11; 5:bytes=8:12;

EVP_aes_128_cbc; EVP_CIPHER* EVP_aes_128_cbc();0; 1; 0:none:1
EVP_aes_192_cbc; EVP_CIPHER* EVP_aes_192_cbc();0; 1; 0:none:1
EVP_aes_256_cbc; EVP_CIPHER* EVP_aes_256_cbc();0; 1; 0:none:1

EVP_aes_128_cfb; EVP_CIPHER* EVP_aes_128_cfb();0; 1; 0:none:1
EVP_aes_192_cfb; EVP_CIPHER* EVP_aes_192_cfb();0; 1; 0:none:1
EVP_aes_256_cfb; EVP_CIPHER* EVP_aes_256_cfb();0; 1; 0:none:1
EVP_aes_128_cfb1; EVP_CIPHER * EVP_aes_128_cfb1(void);0; 1; 0:none:1
EVP_aes_128_cfb128; EVP_CIPHER * EVP_aes_128_cfb128(void);0; 1; 0:none:1
EVP_aes_128_cfb8; EVP_CIPHER * EVP_aes_128_cfb8(void);0; 1; 0:none:1
EVP_aes_192_cfb1; EVP_CIPHER * EVP_aes_192_cfb1(void);0; 1; 0:none:1
EVP_aes_192_cfb128; EVP_CIPHER * EVP_aes_192_cfb128(void);0; 1; 0:none:1
EVP_aes_192_cfb8; EVP_CIPHER * EVP_aes_192_cfb8(void);0; 1; 0:none:1
EVP_aes_256_cfb1; EVP_CIPHER * EVP_aes_256_cfb1(void);0; 1; 0:none:1
EVP_aes_256_cfb128; EVP_CIPHER * EVP_aes_256_cfb128(void);0; 1; 0:none:1
EVP_aes_256_cfb8; EVP_CIPHER * EVP_aes_256_cfb8(void);0; 1; 0:none:1

EVP_aes_128_ofb; EVP_CIPHER* EVP_aes_128_ofb();0; 1; 0:none:1
EVP_aes_192_ofb; EVP_CIPHER* EVP_aes_192_ofb();0; 1; 0:none:1
EVP_aes_256_ofb; EVP_CIPHER* EVP_aes_256_ofb();0; 1; 0:none:1

EVP_aes_128_ecb; EVP_CIPHER* EVP_aes_128_ecb();1; 1; 0:none:13;
EVP_aes_192_ecb; EVP_CIPHER* EVP_aes_192_ecb();1; 1; 0:none:13;
EVP_aes_256_ecb; EVP_CIPHER* EVP_aes_256_ecb();1; 1; 0:none:13;

# DES in CBC, ECB, CFB and OFB modes respectively.
EVP_des_cbc; EVP_CIPHER* EVP_des_cbc();0; 1; 0:none:1
EVP_des_cfb; EVP_CIPHER* EVP_des_cfb();0; 1; 0:none:1
EVP_des_ofb; EVP_CIPHER* EVP_des_ofb();0; 1; 0:none:1
EVP_des_ecb; EVP_CIPHER* EVP_des_ecb();1; 1; 0:none:13;

# Two key triple DES in CBC, ECB, CFB and OFB modes respectively.
EVP_des_ede_cbc; EVP_CIPHER* EVP_des_ede_cbc();0; 1; 0:none:1
EVP_des_ede_ofb; EVP_CIPHER* EVP_des_ede_ofb();0; 1; 0:none:1
EVP_des_ede_cfb; EVP_CIPHER* EVP_des_ede_cfb();0; 1; 0:none:1
EVP_des_ede; EVP_CIPHER* EVP_des_ede();0; 1; 0:none:13;
EVP_des_ede_ecb; EVP_CIPHER* EVP_des_ede_ecb();0; 1; 0:none:13;

# Three key triple DES in CBC, ECB, CFB and OFB modes respectively.
EVP_des_ede3_cbc; EVP_CIPHER* EVP_des_ede3_cbc();0; 1; 0:none:1
EVP_des_ede3_ofb; EVP_CIPHER* EVP_des_ede3_ofb();0; 1; 0:none:1
EVP_des_ede3_cfb; EVP_CIPHER* EVP_des_ede3_cfb();0; 1; 0:none:1
EVP_des_ede3_ecb; EVP_CIPHER* EVP_des_ede3_ecb();0; 1; 0:none:13;
EVP_des_ede3; EVP_CIPHER* EVP_des_ede3();0; 1; 0:none:13;

EVP_des_cfb1; EVP_CIPHER * EVP_des_cfb1(void);0; 1; 0:none:1
EVP_des_cfb64; EVP_CIPHER * EVP_des_cfb64(void);0; 1; 0:none:1
EVP_des_cfb8; EVP_CIPHER * EVP_des_cfb8(void);0; 1; 0:none:1
EVP_des_ede3_cfb1; EVP_CIPHER * EVP_des_ede3_cfb1(void);0; 1; 0:none:1
EVP_des_ede3_cfb64; EVP_CIPHER * EVP_des_ede3_cfb64(void);0; 1; 0:none:1
EVP_des_ede3_cfb8; EVP_CIPHER * EVP_des_ede3_cfb8(void);0; 1; 0:none:1
EVP_des_ede_cfb64; EVP_CIPHER * EVP_des_ede_cfb64(void);0; 1; 0:none:1
EVP_des_ede3_wrap; EVP_CIPHER * EVP_des_ede3_wrap(void);0; 1; 0:none:1

# DESX algorithm in CBC mode.
EVP_desx_cbc; EVP_CIPHER* EVP_desx_cbc();0; 1; 0:none:1

# RC4 stream cipher. This is a variable key length cipher with default key length 128 bits.
EVP_rc4; EVP_CIPHER* EVP_rc4();0; 1; 0:none:1

# RC4 stream cipher with 40 bit key length. This is obsolete and new code should use EVP_rc4() and the EVP_CIPHER_CTX_set_key_length() function.
EVP_rc4_40; EVP_CIPHER* EVP_rc4_40();0; 1; 0:none:1

RC4_set_key; void RC4_set_key(RC4_KEY *key, int len, const unsigned char *data);3; 1; 1:CTX:1; 3:bytes:11; 2:byte:0; 2<3;
RC4; void RC4(RC4_KEY *key, unsigned long len, const unsigned char *indata, unsigned char *outdata); 4; 1; 1:CTX:1; 3:bytes:14; 2:byte:0; 2<3; 4:output:1;

rc4_init_key; int rc4_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key, const unsigned char *iv, int enc); 4; 1; 1:CTX:1; 2:string:11; 3:string:12; 4:int:1

# IDEA encryption algorithm in CBC, ECB, CFB and OFB modes respectively.
EVP_idea_cbc; EVP_CIPHER* EVP_idea_cbc();0; 1; 0:none:1
EVP_idea_ecb; EVP_CIPHER* EVP_idea_ecb();0; 1; 0:none:13
EVP_idea_cfb; EVP_CIPHER* EVP_idea_cfb();0; 1; 0:none:1
EVP_idea_ofb; EVP_CIPHER* EVP_idea_ofb();0; 1; 0:none:1
EVP_idea_cfb64; EVP_CIPHER* EVP_idea_cfb64();0; 1; 0:none:1

# RC2 encryption algorithm in CBC, ECB, CFB and OFB modes respectively.
# This is a variable key length cipher with an additional parameter called "effective key bits" or "effective key length". By default both are set to 128 bits.
EVP_rc2_cbc; EVP_CIPHER* EVP_rc2_cbc();0; 1; 0:none:1
EVP_rc2_ecb; EVP_CIPHER* EVP_rc2_ecb();0; 1; 0:none:13
EVP_rc2_cfb; EVP_CIPHER* EVP_rc2_cfb();0; 1; 0:none:1
EVP_rc2_ofb; EVP_CIPHER* EVP_rc2_ofb();0; 1; 0:none:1
EVP_rc2_cfb64; EVP_CIPHER* EVP_rc2_cfb64();0; 1; 0:none:1

#  RC2 algorithm in CBC mode with a default key length and effective key length of 40 and 64 bits.
#  These are obsolete and new code should use EVP_rc2_cbc(), EVP_CIPHER_CTX_set_key_length() and EVP_CIPHER_CTX_ctrl() to set the key length and effective key length.
EVP_rc2_40_cbc; EVP_CIPHER* EVP_rc2_40_cbc();0; 1; 0:none:1
EVP_rc2_64_cbc; EVP_CIPHER* EVP_rc2_64_cbc();0; 1; 0:none:1

#    Blowfish encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This is a variable key length cipher.
EVP_bf_cbc; EVP_CIPHER* EVP_bf_cbc();0; 1; 0:none:1
EVP_bf_ecb; EVP_CIPHER* EVP_bf_ecb();0; 1; 0:none:13
EVP_bf_cfb; EVP_CIPHER* EVP_bf_cfb();0; 1; 0:none:1
EVP_bf_ofb; EVP_CIPHER* EVP_bf_ofb();0; 1; 0:none:1

EVP_bf_cfb64; EVP_CIPHER * EVP_bf_cfb64(void);0; 1; 0:none:1

#  CAST encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This is a variable key length cipher.
EVP_cast5_cbc; EVP_CIPHER* EVP_cast5_cbc();0; 1; 0:none:1
EVP_cast5_ecb; EVP_CIPHER* EVP_cast5_ecb();0; 1; 0:none:13
EVP_cast5_cfb; EVP_CIPHER* EVP_cast5_cfb();0; 1; 0:none:1
EVP_cast5_ofb; EVP_CIPHER* EVP_cast5_ofb();0; 1; 0:none:1
EVP_cast5_cfb64; const EVP_CIPHER *EVP_cast5_cfb64(void);0; 1; 0:none:1;

# RC5 encryption algorithm in CBC, ECB, CFB and OFB modes respectively.
# This is a variable key length cipher with an additional "number of rounds" parameter.
# By default the key length is set to 128 bits and 12 rounds.
EVP_rc5_32_12_16_cbc; EVP_CIPHER* EVP_rc5_32_12_16_cbc();0; 1; 0:none:1
EVP_rc5_32_12_16_ecb; EVP_CIPHER* EVP_rc5_32_12_16_ecb();0; 1; 0:none:13
EVP_rc5_32_12_16_cfb; EVP_CIPHER* EVP_rc5_32_12_16_cfb();0; 1; 0:none:1
EVP_rc5_32_12_16_ofb; EVP_CIPHER* EVP_rc5_32_12_16_ofb();0; 1; 0:none:1

# set the key length, again prio against other function CTX to get the keylen to CTX to other CTX etc...
EVP_CIPHER_CTX_set_key_length; int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen); 2; 1; 1:CTX:1; 2:keysize:40;

EVP_aes_128_ctr; EVP_CIPHER* EVP_aes_128_ctr();0; 1; 0:none:1
EVP_aes_192_ctr; EVP_CIPHER* EVP_aes_192_ctr();0; 1; 0:none:1
EVP_aes_256_ctr; EVP_CIPHER* EVP_aes_256_ctr();0; 1; 0:none:1

# AES key wrap with 128, 192 and 256 bit keys, as according to RFC 3394 section 2.2.1 ("wrap")
EVP_aes_128_wrap; EVP_CIPHER* EVP_aes_128_wrap();0; 1; 0:none:1
EVP_aes_192_wrap; EVP_CIPHER* EVP_aes_192_wrap();0; 1; 0:none:1
EVP_aes_256_wrap; EVP_CIPHER* EVP_aes_256_wrap();0; 1; 0:none:1

# XTS mode
EVP_aes_128_xts; EVP_CIPHER* EVP_aes_128_xts();0; 1; 0:none:1
EVP_aes_256_xts; EVP_CIPHER* EVP_aes_256_xts();0; 1; 0:none:1


# Camellia cipher
EVP_camellia_128_cbc; EVP_CIPHER * EVP_camellia_128_cbc(void);0; 1; 0:none:1
EVP_camellia_192_cbc; EVP_CIPHER * EVP_camellia_192_cbc(void);0; 1; 0:none:1
EVP_camellia_256_cbc; EVP_CIPHER * EVP_camellia_256_cbc(void);0; 1; 0:none:1

# Camellia
EVP_camellia_128_ecb; void EVP_camellia_128_ecb(int);1; 1; 0:none:13;
EVP_camellia_192_ecb; void EVP_camellia_192_ecb(int);1; 1; 0:none:13;
EVP_camellia_256_ecb; void EVP_camellia_256_ecb(int);1; 1; 0:none:13;

EVP_camellia_128_cfb1; EVP_CIPHER * EVP_camellia_128_cfb1(void);0; 1; 0:none:1
EVP_camellia_128_cfb128; EVP_CIPHER * EVP_camellia_128_cfb128(void);0; 1; 0:none:1
EVP_camellia_128_cfb8; EVP_CIPHER * EVP_camellia_128_cfb8(void);0; 1; 0:none:1
EVP_camellia_128_ofb; EVP_CIPHER * EVP_camellia_128_ofb(void);0; 1; 0:none:1
EVP_camellia_192_cfb1; EVP_CIPHER * EVP_camellia_192_cfb1(void);0; 1; 0:none:1
EVP_camellia_192_cfb128; EVP_CIPHER * EVP_camellia_192_cfb128(void);0; 1; 0:none:1
EVP_camellia_192_cfb8; EVP_CIPHER * EVP_camellia_192_cfb8(void);0; 1; 0:none:1
EVP_camellia_192_ofb; EVP_CIPHER * EVP_camellia_192_ofb(void);0; 1; 0:none:1
EVP_camellia_256_cfb1; EVP_CIPHER * EVP_camellia_256_cfb1(void);0; 1; 0:none:1
EVP_camellia_256_cfb128; EVP_CIPHER * EVP_camellia_256_cfb128(void);0; 1; 0:none:1
EVP_camellia_256_cfb8; EVP_CIPHER * EVP_camellia_256_cfb8(void);0; 1; 0:none:1
EVP_camellia_256_ofb; EVP_CIPHER * EVP_camellia_256_ofb(void);0; 1; 0:none:1


# SEED ENCRYPTION ALGORITHM
EVP_seed_cbc; const EVP_CIPHER *EVP_seed_cbc(void);0; 1; 0:none:1
EVP_seed_cfb; const EVP_CIPHER *EVP_seed_cfb(void);0; 1; 0:none:1
EVP_seed_cfb128; const EVP_CIPHER *EVP_seed_cfb128(void);0; 1; 0:none:1
EVP_seed_ecb; const EVP_CIPHER *EVP_seed_ecb(void);0; 1; 0:none:13
EVP_seed_ofb; const EVP_CIPHER *EVP_seed_ofb(void);0; 1; 0:none:1

# TODO (FUTURE) if the pad parameter is zero then no padding is performed
EVP_CIPHER_CTX_set_padding; int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *x, int padding);2; 1; 1:CTX:1; 2:int:16

BIO_set_cipher; void BIO_set_cipher(BIO *b, const EVP_CIPHER *cipher, unsigned char *key, unsigned char *iv, int enc); 5; 1; 1:CTX:1; 2:CTYPE:1; 3:bytes:11; 4:bytes:12; 5:int:1

CRYPTO_chacha_20; void CRYPTO_chacha_20(uint8_t *out, const uint8_t *in, size_t in_len, const uint8_t key[32], const uint8_t nonce[12], uint32_t counter); 6; 1; 4:bytes=32:11; 5:bytes=12:12; 2:bytes:14; 3:byte:0; 3<2;

# cryptopp
CipherSetKey; CipherSetKey( const NameValuePairs &params, const byte * key,	size_t length ); 3; 1; 2:bytes=32:11; 3:byte:0; 3<2;

# libtomcrypt
find_cipher; int find_cipher(const char *name); 1; 1; 1:CTYPE:40;

des_setup; int des_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey); 3; 1; 1:bytes=8:11; 2:byte:0; 2<1;
des_ecb_encrypt; int des_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey); 3; 1; 0:none:13;
des_ecb_decrypt; int des_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey); 3; 1; 0:none:13;

deskey; void deskey(const unsigned char *key, short edf, ulong32 *keyout); 3; 1; 1:bytes=8:11; 2:byte:0; 2<1;

des3_setup; int des3_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey); 3; 1; 1:bytes=24:11; 2:byte:0; 2<1;
des3_ecb_encrypt; int des3_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey); 3; 1; 0:none:13;
des3_ecb_decrypt; int des3_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey); 3; 1; 0:none:13;

twofish_setup; int twofish_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey); 3; 1; 1:bytes=16=24=32:11; 2:byte:0; 2<1;
twofish_ecb_encrypt; int twofish_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey); 3; 1; 0:none:13
twofish_ecb_decrypt; int twofish_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey); 3; 1; 0:none:13

# from 8 to 56 bytes
blowfish_setup; int blowfish_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey); 3; 1; 1:bytes=8=16=24=32=56:11; 2:byte:0; 2<1;
blowfish_ecb_encrypt; int blowfish_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey); 3; 1; 0:none:13
blowfish_ecb_decrypt; int blowfish_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey); 3; 1; 0:none:13

rijndael_setup; int rijndael_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey); 3; 1; 1:bytes=16=24=32:11; 2:byte:0; 2<1;
rijndael_ecb_encrypt; int rijndael_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey); 3; 1; 0:none:13;
rijndael_ecb_decrypt; int rijndael_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey); 3; 1; 0:none:13;
rijndael_enc_setup; int rijndael_enc_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey); 3; 1; 1:bytes=16=24=32:11; 2:byte:0; 2<1;
rijndael_enc_ecb_encrypt; int rijndael_enc_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey); 3; 1; 0:none:13;

serpent_setup; int serpent_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey); 3; 1; 1:bytes=16=24=32:11; 2:byte:0; 2<1;
serpent_ecb_encrypt; int serpent_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey); 3; 1; 0:none:13;
serpent_ecb_decrypt; int serpent_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey); 3; 1; 0:none:13;

ecb_start; int ecb_start(int cipher, const unsigned char *key, int keylen, int num_rounds, symmetric_ECB *ecb); 5; 1; 2:bytes:11; 3:byte:0; 3<2; 1:CTYPE:1; 5:CTX:1;; 0:none:13;
ecb_encrypt; int ecb_encrypt(const unsigned char *pt, unsigned char *ct, unsigned long len, symmetric_ECB *ecb); 4; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 4:CTX:1; 0:none:13;
ecb_decrypt; int ecb_decrypt(const unsigned char *ct, unsigned char *pt, unsigned long len, symmetric_ECB *ecb); 4; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 4:CTX:1; 0:none:13;

cfb_start; int cfb_start(int cipher, const unsigned char *IV, const unsigned char *key, int keylen, int num_rounds, symmetric_CFB *cfb); 6; 1; 1:CTYPE:1; 2:bytes=16:12; 3:bytes:11; 4:byte:0; 4<3; 4<2;
cfb_encrypt; int cfb_encrypt(const unsigned char *pt, unsigned char *ct, unsigned long len, symmetric_CFB *cfb); 4; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 4:CTX:1
cfb_decrypt; int cfb_decrypt(const unsigned char *ct, unsigned char *pt, unsigned long len, symmetric_CFB *cfb); 4; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 4:CTX:1
cfb_setiv; int cfb_setiv(const unsigned char *IV, unsigned long len, symmetric_CFB *cfb); 3; 1; 1:bytes:1; 2:byte:0; 2<1;

ofb_start; int ofb_start(int cipher, const unsigned char *IV, const unsigned char *key, int keylen, int num_rounds, symmetric_OFB *ofb); 6; 1; 1:CTYPE:1; 2:bytes=16:12; 3:bytes:11; 4:byte:0; 4<3; 4<2;
ofb_encrypt; int ofb_encrypt(const unsigned char *pt, unsigned char *ct, unsigned long len, symmetric_OFB *ofb); 4; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 4:CTX:1
ofb_decrypt; int ofb_decrypt(const unsigned char *ct, unsigned char *pt, unsigned long len, symmetric_OFB *ofb); 4; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 4:CTX:1
ofb_setiv; int ofb_setiv(const unsigned char *IV, unsigned long len, symmetric_OFB *ofb); 3; 1; 1:bytes:1; 2:byte:0; 2<1;

cbc_start; int cbc_start(int cipher, const unsigned char *IV, const unsigned char *key, int keylen, int num_rounds, symmetric_CBC *cbc); 6; 1; 1:CTYPE:1; 2:bytes=16:12; 3:bytes:11; 4:byte:0; 4<3; 4<2;
cbc_encrypt; int cbc_encrypt(const unsigned char *pt, unsigned char *ct, unsigned long len, symmetric_CBC *cbc); 4; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 4:CTX:1
cbc_decrypt; int cbc_decrypt(const unsigned char *ct, unsigned char *pt, unsigned long len, symmetric_CBC *cbc); 4; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 4:CTX:1
cbc_setiv; int cbc_setiv(const unsigned char *IV, unsigned long len, symmetric_CBC *cbc); 3; 1; 1:bytes:1; 2:byte:0; 2<1;

ctr_start; int ctr_start(int cipher, const unsigned char *IV, const unsigned char *key, int keylen, int  num_rounds, int ctr_mode, symmetric_CTR *ctr); 6; 1; 1:CTYPE:1; 2:bytes=16:12; 3:bytes:11; 4:byte:0; 4<3; 4<2;
ctr_encrypt; int ctr_encrypt(const unsigned char *pt, unsigned char *ct, unsigned long len, symmetric_CTR *ctr); 4; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 4:CTX:1
ctr_decrypt; int ctr_decrypt(const unsigned char *ct, unsigned char *pt, unsigned long len, symmetric_CTR *ctr); 4; 1; 1:bytes:14; 2:output:1; 3:byte:0; 3<1; 4:CTX:1
ctr_setiv; int ctr_setiv(const unsigned char *IV, unsigned long len, symmetric_CTR *ctr); 3; 1; 1:bytes=16:1; 2:byte:0; 2<1;

# libc
# DES
setkey; void setkey(const char *key);1; 1; 1:bytes=8:11; 0:none:13;
setkey_r; void setkey_r(const char *key, struct crypt_data *data);2; 1; 1:bytes=8:11; 0:none:13;

encrypt_r; void encrypt_r(char *block, int edflag, struct crypt_data *data);3; 1; 0:none:13;
encrypt; void encrypt(char block[64], int edflag);2 ;1; 0:none:13;

# all uses DES
ecb_crypt; int ecb_crypt(char *key, char *data, unsigned datalen, unsigned mode);3; 1; 0:none:13; 1:bytes=8:11; 2:bytes:14; 3:byte:0; 3<2;
cbc_crypt; int cbc_crypt(char *key, char *data, unsigned datalen, unsigned mode, char *ivec);4; 1; 1:bytes=8:11; 2:bytes:14; 3:byte:0; 3<2; 4:bytes=8:12;

# libgcrypt
gcry_cipher_algo_name; const char * gcry_cipher_algo_name (int algo); 1; 1; 1:CTYPE:40;

# mbedtls
mbedtls_aes_setkey_enc; int mbedtls_aes_setkey_enc( mbedtls_aes_context *ctx, const unsigned char *key, unsigned int keybits ); 3; 1; 1:CTX:1; 2:bytes=16=24=32:11; 3:bit:0; 3<2
mbedtls_aes_setkey_dec; int mbedtls_aes_setkey_dec( mbedtls_aes_context *ctx, const unsigned char *key, unsigned int keybits ); 3; 1; 1:CTX:1; 2:bytes=16=24=32:11; 3:bit:0; 3<2
mbedtls_aes_xts_setkey_enc; int mbedtls_aes_xts_setkey_enc( mbedtls_aes_xts_context *ctx, const unsigned char *key, unsigned int keybits ); 3; 1; 1:CTX:1; 2:bytes=32=64:11; 3:bit:0; 3<2
mbedtls_aes_xts_setkey_dec; int mbedtls_aes_xts_setkey_dec( mbedtls_aes_xts_context *ctx, const unsigned char *key, unsigned int keybits ); 3; 1; 1:CTX:1; 2:bytes=32=64:11; 3:bit:0; 3<2

mbedtls_aes_crypt_ecb; int mbedtls_aes_crypt_ecb( mbedtls_aes_context *ctx, int mode,  const unsigned char input[16], unsigned char output[16]); 4; 1; 1:CTX:1; 2:int:1; 0:none:13; 3:bytes=16:14; 4:output:1
mbedtls_aes_crypt_cbc; int mbedtls_aes_crypt_cbc( mbedtls_aes_context *ctx, int mode, size_t length, unsigned char iv[16], const unsigned char *input, unsigned char *output ); 6; 1; 1:CTX:1; 2:int:1; 3:byte:0; 3<5; 6:output:1; 5:bytes:1; 4:bytes=16:12;
mbedtls_aes_crypt_xts; int mbedtls_aes_crypt_xts( mbedtls_aes_xts_context *ctx, int mode,  size_t length, const unsigned char data_unit[16], const unsigned char *input,  unsigned char *output ); 6; 1; 1:CTX:1; 2:int:1; 3:byte:0; 3<5; 6:output:1; 5:bytes:1; 4:bytes=16:12;
mbedtls_aes_crypt_cfb128; int mbedtls_aes_crypt_cfb128( mbedtls_aes_context *ctx, int mode, size_t length, size_t *iv_off, unsigned char iv[16], const unsigned char *input, unsigned char *output ); 7; 1; 1:CTX:1; 2:int:1; 3:byte:0; 3<6; 7:output:1; 6:bytes:1; 4:bytes=16:12;
mbedtls_aes_crypt_cfb8; int mbedtls_aes_crypt_cfb8( mbedtls_aes_context *ctx, int mode,  size_t length, unsigned char iv[16], const unsigned char *input, unsigned char *output ); 6; 1; 1:CTX:1; 2:int:1; 3:byte:0; 3<5; 6:output:1; 5:bytes:1; 4:bytes=16:12;
mbedtls_aes_crypt_ofb; int mbedtls_aes_crypt_ofb( mbedtls_aes_context *ctx,  size_t length, size_t *iv_off, unsigned char iv[16], const unsigned char *input, unsigned char *output ); 7; 1; 1:CTX:1; 2:int:1; 3:byte:0; 3<6; 7:output:1; 6:bytes:1; 4:bytes=16:12;
mbedtls_aes_crypt_ctr; int mbedtls_aes_crypt_ctr( mbedtls_aes_context *ctx,  size_t length,  size_t *nc_off, unsigned char nonce_counter[16],  unsigned char stream_block[16],  const unsigned char *input, unsigned char *output ); 7; 1; 1:CTX:1; 3:byte:0; 3<6; 7:output:1; 6:bytes:1; 4:bytes=16:12;

# mbedtls_cipher_setup
mbedtls_cipher_setup; int mbedtls_cipher_setup(mbedtls_cipher_context_t *ctx, const mbedtls_cipher_info_t *  cipher_info); 2; 1; 1:CTX:1; 2:CTYPE:40;

mbedtls_internal_aes_encrypt; int mbedtls_internal_aes_encrypt( mbedtls_aes_context *ctx, const unsigned char input[16], unsigned char output[16] );3; 1; 1:CTX:1; 2:bytes=16:14
mbedtls_internal_aes_decrypt; int mbedtls_internal_aes_decrypt( mbedtls_aes_context *ctx, const unsigned char input[16],  unsigned char output[16] );3; 1; 1:CTX:1; 2:bytes=16:14
mbedtls_aes_encrypt; MBEDTLS_DEPRECATED void mbedtls_aes_encrypt( mbedtls_aes_context *ctx, const unsigned char input[16], unsigned char output[16] );3; 1; 1:CTX:1; 2:bytes=16:14
mbedtls_aes_decrypt; MBEDTLS_DEPRECATED void mbedtls_aes_decrypt( mbedtls_aes_context *ctx, const unsigned char input[16], unsigned char output[16] );3; 1; 1:CTX:1; 2:bytes=16:14

mbedtls_arc4_setup; void mbedtls_arc4_setup( mbedtls_arc4_context *ctx, const unsigned char *key, unsigned int keylen ); 3; 1; 1:CTX:1; 2:bytes:11; 3:byte:0; 3<2;
mbedtls_arc4_crypt; int mbedtls_arc4_crypt( mbedtls_arc4_context *ctx, size_t length, const unsigned char *input,  unsigned char *output );4; 1; 1:CTX:1; 2:byte:0; 3:bytes:14; 3<2;

# from 32 - 448 bits
mbedtls_blowfish_setkey; int mbedtls_blowfish_setkey( mbedtls_blowfish_context *ctx, const unsigned char *key, unsigned int keybits );3; 1; 1:CTX:1; 2:bytes=8=16=24=32=56:11; 3:bit:0; 3<2;
mbedtls_blowfish_crypt_ecb; int mbedtls_blowfish_crypt_ecb( mbedtls_blowfish_context *ctx,  int mode, const unsigned char input[MBEDTLS_BLOWFISH_BLOCKSIZE], unsigned char output[MBEDTLS_BLOWFISH_BLOCKSIZE] ); 4; 1; 1:CTX:1; 2:int:1; 1:none:13;
mbedtls_blowfish_crypt_cbc; int mbedtls_blowfish_crypt_cbc( mbedtls_blowfish_context *ctx, int mode, size_t length,  unsigned char iv[MBEDTLS_BLOWFISH_BLOCKSIZE], const unsigned char *input, unsigned char *output ); 6; 1; 1:CTX:1; 2:int:1; 3:byte:0; 3<5; 6:output:1; 5:bytes:1; 4:bytes=8:12;
mbedtls_blowfish_crypt_cfb64; int mbedtls_blowfish_crypt_cfb64( mbedtls_blowfish_context *ctx, int mode, size_t length,  size_t *iv_off,  unsigned char iv[MBEDTLS_BLOWFISH_BLOCKSIZE], const unsigned char *input, unsigned char *output ); 7; 1; 1:CTX:1; 2:int:1; 3:byte:0; 3<6; 7:output:1; 6:bytes:1; 4:bytes=8:12;
mbedtls_blowfish_crypt_ctr; int mbedtls_blowfish_crypt_ctr( mbedtls_blowfish_context *ctx,  size_t length, size_t *nc_off, unsigned char nonce_counter[MBEDTLS_BLOWFISH_BLOCKSIZE],unsigned char stream_block[MBEDTLS_BLOWFISH_BLOCKSIZE], const unsigned char *input, unsigned char *output ); 7; 1; 1:CTX:1; 3:byte:0; 3<6; 7:output:1; 6:bytes:1; 4:bytes=8:12;

mbedtls_camellia_setkey_enc;int mbedtls_camellia_setkey_enc( mbedtls_camellia_context *ctx, const unsigned char *key, unsigned int keybits );3; 1; 1:CTX:1; 2:bytes=16=24=32:11; 3:bit:0; 3<2;
mbedtls_camellia_setkey_dec; int mbedtls_camellia_setkey_dec( mbedtls_camellia_context *ctx,  const unsigned char *key, unsigned int keybits );3; 1; 1:CTX:1; 2:bytes=16=24=32:11; 3:bit:0; 3<2;
mbedtls_camellia_crypt_ecb; int mbedtls_camellia_crypt_ecb( mbedtls_camellia_context *ctx,  int mode, const unsigned char input[16], unsigned char output[16] );4; 1; 1:CTX:1; 2:int:1; 0:none:13; 4:bytes=16:14; 5:output:1;
mbedtls_camellia_crypt_cbc; int mbedtls_camellia_crypt_cbc( mbedtls_camellia_context *ctx, int mode, size_t length, unsigned char iv[16],const unsigned char *input, unsigned char *output );6; 1; 1:CTX:1; 2:int:1; 4:bytes=16:12; 5:bytes:14; 3:int:1; 3<5; 6:output:1;
mbedtls_camellia_crypt_cfb128; int mbedtls_camellia_crypt_cfb128( mbedtls_camellia_context *ctx, int mode, size_t length, size_t *iv_off, unsigned char iv[16], const unsigned char *input, unsigned char *output );7; 1; 1:CTX:1; 2:int:1; 3:byte:0; 3<6; 7:output:1; 6:bytes:1; 4:bytes=16:12; 7:output:1;
mbedtls_camellia_crypt_ctr; int mbedtls_camellia_crypt_ctr( mbedtls_camellia_context *ctx, size_t length, size_t *nc_off, unsigned char nonce_counter[16],  unsigned char stream_block[16], const unsigned char *input, unsigned char *output ); 7; 1; 1:CTX:1; 2:byte:0; 2<6; 7:output:1; 6:bytes:14; 4:bytes=16:12;

mbedtls_des_setkey_enc; int mbedtls_des_setkey_enc( mbedtls_des_context *ctx, const unsigned char key[MBEDTLS_DES_KEY_SIZE] ); 2; 1; 1:CTX:1; 2:bytes=8:11;
mbedtls_des_setkey_dec; int mbedtls_des_setkey_dec( mbedtls_des_context *ctx, const unsigned char key[MBEDTLS_DES_KEY_SIZE] ); 2; 1; 1:CTX:1; 2:bytes=8:11;
mbedtls_des3_set2key_enc; int mbedtls_des3_set2key_enc( mbedtls_des3_context *ctx, const unsigned char key[MBEDTLS_DES_KEY_SIZE * 2] ); 2; 1; 1:CTX:1; 2:bytes=16:11;
mbedtls_des3_set2key_dec; int mbedtls_des3_set2key_dec( mbedtls_des3_context *ctx, const unsigned char key[MBEDTLS_DES_KEY_SIZE * 2] ); 2; 1; 1:CTX:1; 2:bytes=16:11;
mbedtls_des3_set3key_enc; int mbedtls_des3_set3key_enc( mbedtls_des3_context *ctx, const unsigned char key[MBEDTLS_DES_KEY_SIZE * 3] ); 2; 1; 1:CTX:1; 2:bytes=24:11;
mbedtls_des3_set3key_dec; int mbedtls_des3_set3key_dec( mbedtls_des3_context *ctx, const unsigned char key[MBEDTLS_DES_KEY_SIZE * 3] ); 2; 1; 1:CTX:1; 2:bytes=24:11;
mbedtls_des_setkey; void mbedtls_des_setkey( uint32_t SK[32], const unsigned char key[MBEDTLS_DES_KEY_SIZE] ); 2; 1; 2:bytes=8:11;

mbedtls_des_crypt_ecb; int mbedtls_des_crypt_ecb( mbedtls_des_context *ctx, const unsigned char input[8], unsigned char output[8] );3; 1; 0:none:13; 2:bytes=8:14; 1:CTX:1;
mbedtls_des_crypt_cbc; int mbedtls_des_crypt_cbc( mbedtls_des_context *ctx,  int mode, size_t length,  unsigned char iv[8], const unsigned char *input, unsigned char *output ); 6; 1; 1:CTX:1; 2:int:1; 3:byte:0; 3<5; 6:output:1; 5:bytes:14; 4:bytes=8:12;
mbedtls_des3_crypt_ecb; int mbedtls_des3_crypt_ecb( mbedtls_des3_context *ctx, const unsigned char input[8],  unsigned char output[8] );3; 1; 0:none:13; 2:bytes=8:14; 1:CTX:1;
mbedtls_des3_crypt_cbc; int mbedtls_des3_crypt_cbc( mbedtls_des3_context *ctx, int mode, size_t length, unsigned char iv[8], const unsigned char *input, unsigned char *output ); 6; 1; 1:CTX:1; 2:int:1; 3:byte:0; 3<5; 6:output:1; 5:bytes:14; 4:bytes=8:12;

#  The ChaCha20 stream cipher. The key length is 256 bits, the IV is 96 bits long.
EVP_chacha20; EVP_CIPHER* EVP_chacha20(); 0; 1; 0:none:1

#if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)
mbedtls_cipher_set_padding_mode; int mbedtls_cipher_set_padding_mode( mbedtls_cipher_context_t *ctx, mbedtls_cipher_padding_t mode ); 2; 1; 1:CTX:1; 2:int:16;


mbedtls_cipher_setkey; int mbedtls_cipher_setkey( mbedtls_cipher_context_t *ctx,  const unsigned char *key,  int key_bitlen, const mbedtls_operation_t operation );4; 1; 1:CTX:1; 2:bytes:11; 3:bit:0; 3<2;
mbedtls_cipher_set_iv; int mbedtls_cipher_set_iv( mbedtls_cipher_context_t *ctx, const unsigned char *iv, size_t iv_len ); 3; 1; 2:bytes:12; 3:byte:0; 3<2; 1:CTX:1;
mbedtls_cipher_crypt; int mbedtls_cipher_crypt( mbedtls_cipher_context_t *ctx, const unsigned char *iv, size_t iv_len, const unsigned char *input, size_t ilen, unsigned char *output, size_t *olen );7 ; 1; 1:CTX:1; 2:bytes:12; 3:byte:0; 3<2; 4:bytes:14; 5:byte:0; 5<4; 6:output:1;
mbedtls_cipher_update; int mbedtls_cipher_update( mbedtls_cipher_context_t *ctx, const unsigned char *input, size_t ilen, unsigned char *output, size_t *olen ); 5; 1; 1:CTX:1; 2:bytes:14; 3:byte:0; 3<2; 4:output:1;

#mbedtls_cipher_info_from_string; const mbedtls_cipher_info_t *mbedtls_cipher_info_from_string( const char *cipher_name ); 1; 1; 1:string:40
mbedtls_cipher_info_from_type; const mbedtls_cipher_info_t *mbedtls_cipher_info_from_type( const mbedtls_cipher_type_t cipher_type ); 1; 1; 1:CTYPE:40;
#mbedtls_cipher_info_from_values; const mbedtls_cipher_info_t *mbedtls_cipher_info_from_values( const mbedtls_cipher_id_t cipher_id, int key_bitlen, const mbedtls_cipher_mode_t mode ); 3; 1; 1:int:1; 2:int:40; 3:int:3;

# ---------------------------------------------------------------------------------------------------------------------------- #
# ------------------------------------------ PSEUDORANDOM NUMBER GENERATORS -------------------------------------------------- #
# ---------------------------------------------------------------------------------------------------------------------------- #
rand; void rand();0; 6; 0:none:61
# change to CTX to capture seed with time(), or any other function
srand; void srand (unsigned int seed);1; 6; 1:CTX:62
srand48; void srand48(long int seedval);1; 6; 1:CTX:62
rand_r; int rand_r(unsigned int *seedp);1; 6; 0:bytes:62
mrand48; long int mrand48(void);0; 6; 0:none:61
lrand48; long int lrand48(void);0; 6; 0:none:61
drand48; double drand48(void);0; 6; 0:none:61
random; long int random(void);0; 6; 0:none:6
drand48_r; int drand48_r (struct drand48_data *buffer, double *result);2; 6; 0:none:61; 1:output:6

seed48; unsigned short *seed48(unsigned short seed16v[3]); 1; 6; 1:bytes:61;

srandom; void srandom(unsigned int seed);1; 6; 1:CTX:62
arc4random; uint32_t arc4random(void);0; 6; 0:none:6
arc4random_buf; void arc4random_buf(void *buf, size_t nbytes);2; 6; 0:none:6
arc4random_uniform; uint32_t arc4random_uniform(uint32_t upper_bound);1; 6; 0:none:6

# OpenSSL libssl and libcrypto  #
# extra checks
# RAND_seed() is equivalent to RAND_add() when num == entropy.
# RAND_add() may be called with sensitive data such as user entered passwords. The seed values cannot be recovered from the PRNG output.
# OpenSSL makes sure that the PRNG state is unique for each thread. On systems that provide /dev/urandom,
# the randomness device is used to seed the PRNG transparently.
# However, on all other systems, the application is responsible for seeding the PRNG by calling RAND_add(), RAND_egd(3) or RAND_load_file(3).
RAND_seed; void RAND_seed(const void *buf, int num); 2; 6; 1:CTX:62; 2:int:0; 2<1
wolfSSL_RAND_seed; void wolfSSL_RAND_seed(const void *buf, int num); 2; 6; 1:CTX:62; 2:int:0; 2<1
RAND_add; void RAND_add(const void *buf, int num, double entropy); 2; 6; 1:CTX:62; 2:int:0; 2<1
RAND_load_file; int RAND_load_file(const char *filename, long max_bytes); 2; 6; 1:string:40;


RAND_bytes; int  RAND_bytes(unsigned char *buf, int num); 2; 6; 1:output:6; 2:int:0; 2<1
# They can be used for non-cryptographic purposes and
# for certain purposes in cryptographic protocols, but usually not for key generation etc.
# Deprecated
RAND_pseudo_bytes; int RAND_pseudo_bytes(unsigned char *buf, int num); 2; 6; 1:output:61; 2:int:0; 2<1

#libgcrypt
#    Fill buffer with length random bytes using a random quality as defined by level.
gcry_randomize; void gcry_randomize (unsigned char *buffer, size_t length, enum gcry_random_level level); 3; 6; 0:none:6; 3:int:40
#    Convenience function to allocate a memory block consisting of nbytes fresh random bytes using a random quality as defined by level.
gcry_random_bytes; void * gcry_random_bytes (size_t nbytes, enum gcry_random_level level); 2; 6; 0:none:6; 2:int:40

# ---------------------------------------------------------------------------------------------------------------------------- #
# -------------------------------------- HASH FUNCTIONS UNKEYED -------------------------------------------------------------- #
# ---------------------------------------------------------------------------------------------------------------------------- #

# OpenSSL libssl and libcrypto  #
# --------- MD2 --------------- #
#include <openssl/md2.h>
MD2; unsigned char *MD2(const unsigned char *d, unsigned long n, unsigned char *md); 3; 8; 1:bytes:81; 2:byte:0 ; 2<1
MD2_Init; int MD2_Init(MD2_CTX *c); 1; 8; 1:CTX:1;
MD2_Update; int MD2_Update(MD2_CTX *c, const unsigned char *data, unsigned long len); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0 ; 3<2
MD2_Final; int MD2_Final(unsigned char *md, MD2_CTX *c);2; 8; 1:output:8; 2:CTX:8;
EVP_md2; const EVP_MD *EVP_md2(void); 0; 8; 0:none:8;

# --------- MD4 --------------- #
#include <openssl/md4.h>
MD4; unsigned char *MD4(const unsigned char *d, unsigned long n, unsigned char *md); 3; 8; 1:bytes:81; 2:byte:0 ; 2<1
MD4_Init; int MD4_Init(MD4_CTX *c); 1; 8; 1:CTX:1;
MD4_Update; int MD4_Update(MD4_CTX *c, const void *data, unsigned long len); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0 ; 3<2
MD4_Final; int MD4_Final(unsigned char *md, MD4_CTX *c); 2; 8; 1:output:8; 2:CTX:8;
EVP_md4; const EVP_MD *EVP_md4(void); 0; 8; 0:none:8;

# --------- MD5 --------------- #
#include <openssl/md5.h>
MD5; unsigned char *MD5(const unsigned char *d, unsigned long n, unsigned char *md); 3; 8; 1:bytes:81; 2:byte:0; 3:output:8; 2<1
MD5_Init; int MD5_Init(MD5_CTX *c); 1; 8; 1:CTX:1;
CyaSSL_MD5_Init; int MD5_Init(MD5_CTX *c); 1; 8; 1:CTX:1;
WolfSSL_MD5_Init; int MD5_Init(MD5_CTX *c); 1; 8; 1:CTX:1;
MD5_Update; int MD5_Update(MD5_CTX *c, const void *data, unsigned long len); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2
CyaSSL_MD5_Update; int MD5_Update(MD5_CTX *c, const void *data, unsigned long len); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2
WolfSSL_MD5_Update; int MD5_Update(MD5_CTX *c, const void *data, unsigned long len); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2
MD5_Final; int MD5_Final(unsigned char *md, MD5_CTX *c); 2; 8; 1:output:8; 2:CTX:8;
CyaSSL_MD5_Final; int MD5_Final(unsigned char *md, MD5_CTX *c); 2; 8; 1:output:8; 2:CTX:8;
WolfSSL_MD5_Final; int MD5_Final(unsigned char *md, MD5_CTX *c); 2; 8; 1:output:8; 2:CTX:8;
EVP_md5; const EVP_MD *EVP_md5(void); 0; 8; 0:none:8;
CyaSSL_EVP_md5; const EVP_MD *CyaSSL_EVP_md5(void); 0; 8; 0:none:8;
WolfSSL_EVP_md5; const EVP_MD *CyaSSL_EVP_md5(void); 0; 8; 0:none:8;

# --------- SHA0 --------------- #
# --------- removed in new version of openssl --------------- #
#include <openssl/sha.h>
SHA_Init; int SHA_Init(SHA_CTX *c); 1; 8; 1:CTX:1;
CyaSSL_SHA_Init; int CyaSSL_SHA_Init(SHA_CTX *c); 1; 8; 1:CTX:1;
SHA_Update; int SHA_Update(SHA_CTX *c, const void *data, size_t len); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0 ; 3<2
CyaSSL_SHA_Update; int CyaSSL_SHA_Update(SHA_CTX *c, const void *data, size_t len); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0 ; 3<2
SHA_Final; int SHA_Final(unsigned char *md, SHA_CTX *c); 2; 8; 1:output:8; 2:CTX:8;
CyaSSL_SHA_Final; int CyaSSL_SHA_Final(unsigned char *md, SHA_CTX *c); 2; 8; 1:output:8; 2:CTX:8;
SHA; unsigned char *SHA(const unsigned char *d, size_t n, unsigned char *md); 3; 8; 1:bytes:81; 2:byte:0; 2<1
EVP_sha; const EVP_MD *EVP_sha(void); 0; 8; 0:none:8
EVP_dss; const EVP_MD *EVP_dss(void); 0; 8; 0:none:8

# --------- SHA1 --------------- #
#include <openssl/sha.h>
SHA1_Init; int SHA1_Init(SHA_CTX *c); 1; 8; 1:CTX:1;
SHA1_Update; int SHA1_Update(SHA_CTX *c, const void *data, size_t len); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0 ; 3<2
SHA1_Final; int SHA1_Final(unsigned char *md, SHA_CTX *c); 2; 8; 1:output:8; 2:CTX:8;
SHA1; unsigned char *SHA1(const unsigned char *d, size_t n, unsigned char *md); 3; 8; 1:bytes:81; 2:byte:0; 2<1
EVP_sha1; const EVP_MD *EVP_sha1(void);0; 8; 0:none:8
CyaSSL_EVP_sha1; const EVP_MD *CyaSSL_EVP_sha1(void);0; 8; 0:none:8
EVP_dss1; const EVP_MD *EVP_dss1(void);0; 8; 0:none:8

# --------- SHA224 --------------- #
#include <openssl/sha.h>
SHA224_Init; int SHA224_Init(SHA256_CTX *c); 1; 8; 1:CTX:1;
SHA224_Update; int SHA224_Update(SHA256_CTX *c, const void *data, size_t len); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0 ; 3<2
SHA224_Final; int SHA224_Final(unsigned char *md, SHA256_CTX *c); 2; 8; 1:output:8; 2:CTX:8;
SHA224; unsigned char *SHA224(const unsigned char *d, size_t n, unsigned char *md); 3; 8; 1:bytes:81; 2:byte:0; 2<1
EVP_sha224; const EVP_MD *EVP_sha224(void);0; 8; 0:none:8

# --------- SHA256 --------------- #
#include <openssl/sha.h>
SHA256_Init; int SHA256_Init(SHA256_CTX *c); 1; 8; 1:CTX:1;
CyaSSL_SHA256_Init; int CyaSSL_SHA256_Init(SHA256_CTX *c); 1; 8; 1:CTX:1;
SHA256_Update; int SHA256_Update(SHA256_CTX *c, const void *data, size_t len); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2
CyaSSL_SHA256_Update; int CyaSSL_SHA256_Update(SHA256_CTX *c, const void *data, size_t len); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2
SHA256_Final; int SHA256_Final(unsigned char *md, SHA256_CTX *c); 2; 8; 1:output:8; 2:CTX:8;
CyaSSL_SHA256_Final; int CyaSSL_SHA256_Final(unsigned char *md, SHA256_CTX *c); 2; 8; 1:output:8; 2:CTX:8;
SHA256; unsigned char *SHA256(const unsigned char *d, size_t n, unsigned char *md); 3; 8; 1:bytes:81; 2:byte:0; 2<1
EVP_sha256; const EVP_MD *EVP_sha256(void);0; 8; 0:none:8;

# --------- SHA384 --------------- #
#include <openssl/sha.h>
SHA384_Init; int SHA384_Init(SHA512_CTX *c); 1; 8; 1:CTX:1;
SHA384_Update; int SHA384_Update(SHA512_CTX *c, const void *data, size_t len); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2
SHA384_Final; int SHA384_Final(unsigned char *md, SHA512_CTX *c); 2; 8; 1:output:8; 2:CTX:8;
SHA384; unsigned char *SHA384(const unsigned char *d, size_t n, unsigned char *md); 3; 8; 1:bytes:81; 2:byte:0 ; 2<1
EVP_sha384; const EVP_MD *EVP_sha384(void);0; 8; 0:none:8;

# --------- SHA512 --------------- #
#include <openssl/sha.h>
SHA512_Init; int SHA512_Init(SHA512_CTX *c); 1; 8; 1:CTX:1;
SHA512_Update; int SHA512_Update(SHA512_CTX *c, const void *data, size_t len); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0 ; 3<2
SHA512_Final; int SHA512_Final(unsigned char *md, SHA512_CTX *c); 2; 8; 1:output:8; 2:CTX:8;
SHA512; unsigned char *SHA512(const unsigned char *d, size_t n, unsigned char *md); 3; 8; 1:bytes:81; 2:byte:0; 2<1
EVP_sha512; const EVP_MD *EVP_sha512(void);0; 8; 0:none:8;

# --------- RIPEMD-160  --------------- #
#include <openssl/ripemd.h>
RIPEMD160; unsigned char *RIPEMD160(const unsigned char *d, unsigned long n, unsigned char *md);3; 8; 1:bytes:81; 2:byte:0 ; 2<1
RIPEMD160_Init; int RIPEMD160_Init(RIPEMD160_CTX *c); 1; 8; 1:CTX:1;
RIPEMD160_Update; int RIPEMD160_Update(RIPEMD_CTX *c, const void *data, unsigned long len);3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2
RIPEMD160_Final; int RIPEMD160_Final(unsigned char *md, RIPEMD160_CTX *c);2; 8; 1:output:8; 2:CTX:8;
EVP_ripemd160; const EVP_MD *EVP_ripemd160(void);0; 8; 0:none:8;

# --------- MDC2 --------------- #
#include <openssl/mdc2.h>
MDC2; unsigned char *MDC2(const unsigned char *d, unsigned long n, unsigned char *md);3; 8; 1:bytes:81; 2:byte:0 ; 2<1
MDC2_Init; int MDC2_Init(MDC2_CTX *c); 1; 8; 1:CTX:1;
MDC2_Update; int MDC2_Update(MDC2_CTX *c, const unsigned char *data, unsigned long len);3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2
MDC2_Final; int MDC2_Final(unsigned char *md, MDC2_CTX *c);2; 8; 1:output:8; 2:CTX:8;
EVP_mdc2; EVP_mdc2 const EVP_MD *EVP_mdc2(void);0; 8; 0:none:8;

# --------- BLAKE legacy support --------------- #
EVP_blake2b512; const EVP_MD *EVP_blake2b512(void);0; 8; 0:none:8;
EVP_blake2s256; const EVP_MD *EVP_blake2s256(void);0; 8; 0:none:8;

# --------- OpenSSL general hashing--------------- #
#include <openssl/evp.h>

EVP_DigestInit_ex; int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);3; 8; 1:CTX:8; 2:CTYPE:8;
EVP_DigestUpdate; int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt);3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2
EVP_DigestFinal_ex; int EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *s);3; 8; 1:CTX:8; 2:output:8;

EVP_DigestInit; int EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type);3; 8; 1:CTX:8; 2:CTYPE:8;
EVP_DigestFinal; int EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *s);3; 8; 1:CTX:8; 2:output:8;
CyaSSL_EVP_DigestFinal; int CyaSSL_EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *s);3; 8; 1:CTX:8; 2:output:8;
EVP_DigestFinalXOF; int EVP_DigestFinalXOF(EVP_MD_CTX *ctx, unsigned char *md, size_t len);3; 8; 1:CTX:8; 2:output:8;

# --------- WHIRLPOOL --------------- #
EVP_whirlpool; const EVP_MD *EVP_whirlpool(void);0; 8; 0:none:8;

# added to post rules
EVP_get_digestbyname; const EVP_MD *EVP_get_digestbyname(const char *name); 1; 8; 1:string:40;

# Libgcrypt is a general purpose cryptographic library originally based on code from GnuPG
# ----------------- Libgcrypt -----------------------------#
gcry_md_open; gcry_error_t gcry_md_open (gcry_md_hd_t *hd, int algo, unsigned int flags);3; 8; 2:CTYPE:8; 3:CTX:40; 1:CTX:8; 3<1; 3<2;
gcry_md_read; unsigned char * gcry_md_read (gcry_md_hd_t h, int algo);2; 8; 1:CTX:8; 2:CTYPE:8;
gcry_md_enable; gcry_error_t gcry_md_enable (gcry_md_hd_t h, int algo);2; 8; 1:CTX:8; 2:CTYPE:8;
gcry_md_extract; gpg_err_code_t gcry_md_extract (gcry_md_hd_t h, int algo, void *buffer, size_t length);4; 8; 1:CTX:8; 2:CTYPE:8; 3:output:8;
gcry_md_hash_buffers; gpg_err_code_t gcry_md_hash_buffers (int algo, unsigned int flags, void *digest, const gcry_buffer_t *iov, int iovcnt );5; 8; 1:CTYPE:8; 2:int:40; 3:output:8;
gcry_md_hash_buffer; void gcry_md_hash_buffer (int algo, void *digest, const void *buffer, size_t length); 4; 8; 1:CTYPE:8; 2:output:8; 3:bytes:81; 4:byte:0; 4<3;

# it will keep on pushing the data through the algorithm specific transform function and change the context;
# however the results are not meaningful and this feature is only available to mitigate timing attacks.
gcry_md_write; void gcry_md_write (gcry_md_hd_t h, const void *buffer, size_t length); 3; 8; 1:CTX:1; 2:bytes:81; 3:byte:0; 3<2;

wc_ShaHash; int 	wc_ShaHash (const byte *, word32, byte *); 3; 8; 1:bytes:81; 2:byte:0; 2<1; 3:output:8
wc_Sha256Hash; int 	wc_Sha256Hash (const byte *, word32, byte *); 3; 8; 1:bytes:81; 2:byte:0; 2<1; 3:output:8
wc_Sha224Hash; int 	wc_Sha224Hash (const byte *, word32, byte *); 3; 8; 1:bytes:81; 2:byte:0; 2<1; 3:output:8
wc_Sha512Hash; int 	wc_Sha512Hash (const byte *, word32, byte *); 3; 8; 1:bytes:81; 2:byte:0; 2<1; 3:output:8
wc_Sha384Hash; int 	wc_Sha384Hash (const byte *, word32, byte *); 3; 8; 1:bytes:81; 2:byte:0; 2<1; 3:output:8

wc_InitSha; int 	wc_InitSha (wc_Sha *); 1; 8; 1:CTX:8;
wc_ShaUpdate; int 	wc_ShaUpdate (wc_Sha *, const byte *, word32); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2;
wc_ShaFinal; int 	wc_ShaFinal (wc_Sha *, byte *); 2; 8; 1:CTX:8; 2:output:8;
wc_ShaGetHash; int 	wc_ShaGetHash (wc_Sha *, byte *); 2; 8; 1:CTX:8; 2:output:8;

wc_InitSha256; int 	wc_InitSha256 (wc_Sha256 *); 1; 8; 1:CTX:8;
wc_Sha256Update; int 	wc_Sha256Update (wc_Sha256 *, const byte *, word32); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2;
wc_Sha256Final; int 	wc_Sha256Final (wc_Sha256 *, byte *); 2; 8; 1:CTX:8; 2:output:8;
wc_Sha256GetHash; int 	wc_Sha256GetHash (wc_Sha256 *, byte *); 2; 8; 1:CTX:8; 2:output:8;

wc_InitSha224; int 	wc_InitSha224 (wc_Sha224 *); 1; 8; 1:CTX:8;
wc_Sha224Update; int 	wc_Sha224Update (wc_Sha224 *, const byte *, word32); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2;
wc_Sha224Final; int 	wc_Sha224Final (wc_Sha224 *, byte *); 2; 8; 1:CTX:8; 2:output:8;

wc_InitSha512; int 	wc_InitSha512 (wc_Sha512 *); 1; 8; 1:CTX:8;
wc_Sha512Update; int 	wc_Sha512Update (wc_Sha512 *, const byte *, word32); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2;
wc_Sha512Final; int 	wc_Sha512Final (wc_Sha512 *, byte *); 2; 8; 1:CTX:8; 2:output:8;

wc_InitSha384; int 	wc_InitSha384 (wc_Sha384 *); 1; 8; 1:CTX:8;
wc_Sha384Update; int 	wc_Sha384Update (wc_Sha384 *, const byte *, word32); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2;
wc_Sha384Final; int 	wc_Sha384Final (wc_Sha384 *, byte *); 2; 8; 1:CTX:8; 2:output:8;

wc_Md5Hash; int wc_Md5Hash (const byte *data, word32 len, byte *hash); 3; 8; 1:bytes:81; 2:byte:0; 2<1; 3:output:8
wc_InitMd5; int wc_InitMd5 (wc_Md5 *); 1; 8; 1:CTX:8;
wc_Md5Update; int wc_Md5Update (wc_Md5 *, const byte *, word32); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2;
wc_Md5Final; int wc_Md5Final (wc_Md5 *, byte *); 2; 8; 1:CTX:8; 2:output:8;
wc_Md5GetHash; int wc_Md5GetHash (wc_Md5 *, byte *); 2; 8; 1:CTX:8; 2:output:8;

# https://nxmnpg.lemoda.net/3/MD4Final
# Support Library (libmd, -lmd)
# FreeBSD
MD5Update; int MD5Update(MD4_CTX *c, const void *data, unsigned long len); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0 ; 3<2
MD5Final; void MD5Final(unsigned char digest[16], MD5_CTX *context); 2; 8; 1:output:8; 2:CTX:8;
MD5Init; void MD5Init(MD5_CTX *context); 1; 8; 1:CTX:8;

MD4Update; int MD4Update(MD4_CTX *c, const void *data, unsigned long len); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0 ; 3<2
MD4Final; void MD4Final(unsigned char digest[16], MD5_CTX *context); 2; 8; 1:output:8; 2:CTX:8;
MD4Init; void MD4Init(MD5_CTX *context); 1; 8; 1:CTX:8;

SHA1Update; int SHA1Update(MD4_CTX *c, const void *data, unsigned long len); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0 ; 3<2
SHA1Final; void SHA1Final(unsigned char digest[16], MD5_CTX *context); 2; 8; 1:output:8; 2:CTX:8;
SHA1Init; void SHA1Init(MD5_CTX *context); 1; 8; 1:CTX:8;

SHA256Update; int SHA256Update(MD4_CTX *c, const void *data, unsigned long len); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0 ; 3<2
SHA256Final; void SHA256Final(unsigned char digest[16], MD5_CTX *context); 2; 8; 1:output:8; 2:CTX:8;
SHA256Init; void SHA256Init(MD5_CTX *context); 1; 8; 1:CTX:8;

SHA384Update; int SHA384Update(MD4_CTX *c, const void *data, unsigned long len); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0 ; 3<2
SHA384Final; void SHA384Final(unsigned char digest[16], MD5_CTX *context); 2; 8; 1:output:8; 2:CTX:8;
SHA384Init; void SHA384Init(MD5_CTX *context); 1; 8; 1:CTX:8;

SHA512Update; int SHA512Update(MD4_CTX *c, const void *data, unsigned long len); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0 ; 3<2
SHA512Final; void SHA512Final(unsigned char digest[16], MD5_CTX *context); 2; 8; 1:output:8; 2:CTX:8;
SHA512Init; void SHA512Init(MD5_CTX *context); 1; 8; 1:CTX:8;

# libtomcrypt
sha1_init; int sha1_init (hash_state * md); 1; 8; 1:CTX:8;
sha256_init; int sha256_init(hash_state * md); 1; 8; 1:CTX:8;
sha512_init; int sha512_init(hash_state * md); 1; 8; 1:CTX:8;
sha384_init; int sha384_init (hash_state * md); 1; 8; 1:CTX:8;
md5_init; int md5_init(hash_state * md); 1; 8; 1:CTX:8;
md4_init; int md4_init (hash_state * md); 1; 8; 1:CTX:8;

# mbedtls
mbedtls_sha256_init; void mbedtls_sha256_init( mbedtls_sha256_context *ctx ); 1; 8; 1:CTX:8;
mbedtls_sha256_update_ret; int mbedtls_sha256_update_ret( mbedtls_sha256_context *ctx,const unsigned char *input, size_t ilen ); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2;
mbedtls_sha256_update; int mbedtls_sha256_update( mbedtls_sha256_context *ctx,const unsigned char *input, size_t ilen ); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2;
mbedtls_sha256_finish_ret; int mbedtls_sha256_finish_ret( mbedtls_sha256_context *ctx,  unsigned char output[32] ); 2; 8; 1:CTX:8; 2:output:1;
mbedtls_sha256_finish; int mbedtls_sha256_finish( mbedtls_sha256_context *ctx,  unsigned char output[32] ); 2; 8; 1:CTX:8; 2:output:1;
mbedtls_sha256; void mbedtls_sha256( const unsigned char *input,  size_t ilen,  unsigned char output[32],  int is224 ); 4; 8; 1:bytes:81; 2:byte:0; 2<1; 3:output:8; 4:int:40;
# TODO (FUTURE) fix to the correct hash function on 40 is?
mbedtls_sha256_starts_ret; uint mbedtls_sha256_starts_ret( mbedtls_sha256_context *ctx, int is224 );  2; 8; 1:CTX:8; 2:int:40;
mbedtls_sha256_starts; void mbedtls_sha256_starts( mbedtls_sha256_context *ctx, int is224 );  2; 8; 1:CTX:8; 2:int:40;

mbedtls_sha512_init; void mbedtls_sha512_init( mbedtls_sha512_context *ctx ); 1; 8; 1:CTX:8;
mbedtls_sha512_update; int mbedtls_sha512_update( mbedtls_sha512_update *ctx,const unsigned char *input, size_t ilen ); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2;
mbedtls_sha512_update_ret; int mbedtls_sha512_update_ret( mbedtls_sha512_update *ctx,const unsigned char *input, size_t ilen ); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2;
mbedtls_sha512_finish_ret; int mbedtls_sha512_finish_ret( mbedtls_sha512_finish *ctx,  unsigned char output[64] ); 2; 8; 1:CTX:8; 2:output:1;
mbedtls_sha512_finish; int mbedtls_sha512_finish( mbedtls_sha512_finish *ctx,  unsigned char output[64] ); 2; 8; 1:CTX:8; 2:output:1;
mbedtls_sha512; void mbedtls_sha512( const unsigned char *input,  size_t ilen,  unsigned char output[64],  int is384 ); 4; 8; 1:bytes:81; 2:byte:0; 2<1; 3:output:8; 4:int:40;
mbedtls_sha512_starts; void mbedtls_sha512_starts_ret( mbedtls_sha512_starts_ret *ctx, int is384 );  2; 8; 1:CTX:8; 2:int:40;
mbedtls_sha512_starts_ret; void mbedtls_sha512_starts_ret( mbedtls_sha512_starts_ret *ctx, int is384 );  2; 8; 1:CTX:8; 2:int:40;

mbedtls_sha1_init; void mbedtls_sha1_init( mbedtls_sha1_context *ctx ); 1; 8; 1:CTX:8;
mbedtls_sha1_update; void mbedtls_sha1_update( mbedtls_sha1_context *ctx, const unsigned char *input, size_t ilen ); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2;
mbedtls_sha1_finish; void mbedtls_sha1_finish( mbedtls_sha1_context *ctx, unsigned char output[20] ); 2; 8; 1:CTX:8; 2:output:1;
mbedtls_sha1; void mbedtls_sha1( const unsigned char *input, size_t ilen, unsigned char output[20] ); 3; 8; 1:bytes:81; 2:byte:0; 2<1; 3:output:8;
mbedtls_sha1_starts; void mbedtls_sha1_starts( mbedtls_sha1_context *ctx ); 1; 8; 1:CTX:8;

mbedtls_md5_init; void mbedtls_md5_init( mbedtls_md5_context *ctx ); 1;  8; 1:CTX:8;
mbedtls_md5_update; void mbedtls_md5_update( mbedtls_md5_context *ctx, const unsigned char *input, size_t ilen ); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2;
mbedtls_md5_finish; void mbedtls_md5_finish( mbedtls_md5_context *ctx,  unsigned char output[16] ); 2; 8; 1:CTX:8; 2:output:1;
mbedtls_md5; void mbedtls_md5( const unsigned char *input, size_t ilen, unsigned char output[16] ); 3; 8; 1:bytes:81; 2:byte:0; 2<1; 3:output:8;

mbedtls_ripemd160_init; void mbedtls_ripemd160_init(  mbedtls_ripemd160_context *ctx ); 1; 8; 1:CTX:8;
mbedtls_ripemd160_update; void mbedtls_ripemd160_update(  mbedtls_ripemd160_context *ctx, const unsigned char *input, size_t ilen ); 3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2;
mbedtls_ripemd160_finish; void mbedtls_ripemd160_finish(  mbedtls_ripemd160_context *ctx,  unsigned char output[20] ); 2; 8; 1:CTX:8; 2:output:1;
mbedtls_ripemd160; void mbedtls_ripemd160( const  mbedtls_ripemd160_context char *input, size_t ilen, unsigned char output[20] ); 3; 8; 1:bytes:81; 2:byte:0; 2<1; 3:output:8;

mbedtls_md_init_ctx; int mbedtls_md_init_ctx( mbedtls_md_context_t *ctx, const mbedtls_md_info_t *md_info );2; 8; 1:CTX:8; 2:CTYPE:8;
mbedtls_md_setup; int mbedtls_md_setup( mbedtls_md_context_t *ctx, const mbedtls_md_info_t *md_info, int hmac );3; 8; 3:CTX:40; 1:CTX:8; 2:CTYPE:8;
mbedtls_md_update; int mbedtls_md_update( mbedtls_md_context_t *ctx, const unsigned char *input, size_t ilen );3; 8; 1:CTX:8; 2:bytes:81; 3:byte:0; 3<2;
mbedtls_md_finish; int mbedtls_md_finish( mbedtls_md_context_t *ctx, unsigned char *output ); 2; 8; 1:CTX:8; 2:output:1;
mbedtls_md; int mbedtls_md( const mbedtls_md_info_t *md_info, const unsigned char *input, size_t ilen, unsigned char *output );4; 8; 1:CTYPE:8; 2:bytes:81; 3:byte:0; 3<2; 4:output:1;

mbedtls_md_info_from_string; const mbedtls_md_info_t* mbedtls_md_info_from_string(const char *  md_name);1; 8; 1:string:40;
mbedtls_md_info_from_type; const mbedtls_md_info_t* mbedtls_md_info_from_type(mbedtls_md_type_t md_type);1; 8; 1:int:40;

# ---------------------------------------------------------------------------------------------------------------------------- #
# --------------------------------- Key Derivation Functions and Password hashing -------------------------------------------- #
# ---------------------------------------------------------------------------------------------------------------------------- #
#libsodium;;;
#Nettle;;;
#openssl;;;
#libtomcrypt;;;
#libk5crypto;;;
#libbcmcrypto;;;
#libcrypt;;;
# POST RESULTS FOR CRYPT
# ex $1$ -> uses MD5
# ex $2a$ -> Blowfish (not in all)
# ex $5$ -> uses SHA256
# ex $6$ -> uses SHA512
# other  -> uses DES
# http://man7.org/linux/man-pages/man3/crypt.3.html#NOTES
# $id$rounds=yyy$salt$encrypted (since glibc 2.7)
crypt; char * crypt(char * __key, char * __salt);2 ; 9; 1:string:91; 2:string:92

DES_fcrypt; char *DES_fcrypt(const char *buf, const char *salt, char *ret);3; 9; 1:string:91; 2:string:92
DES_crypt; char *DES_crypt(const char *buf, const char *salt);2; 9; 1:string:91; 2:string:92

# Password hash
# The GNU C Library includes only a few special-purpose cryptographic functions:
# one-way hash functions for passphrase storage, and access to a cryptographic randomness source, if one is provided by the operating system.
# Function:
crypt_r; char * crypt_r (const char *phrase, const char *salt, struct crypt_data *data); 3; 9; 1:string:91; 2:string:92;

gcry_md_algo_name; const char * gcry_md_algo_name(int algo); 1; 9; 1:CTYPE:9;
gcry_md_map_name; int gcry_md_map_name(const char *name); 1; 9; 1:CTYPE:9;

# OpenSSL libssl and libcrypto
# deprecated!!!! KDF
EVP_BytesToKey; int EVP_BytesToKey(const EVP_CIPHER *type, const EVP_MD *md,const unsigned char *salt, const unsigned char *data, int datal, int count, unsigned char *key,unsigned char *iv);8; 9; 1:CTYPE:9; 2:CTYPE:9; 3:bytes=8:92; 4:bytes:91; 5:byte:0; 6:int:93; 7:output:9; 8:output:9; 5<4
CyaSSL_EVP_BytesToKey; int CyaSSL_EVP_BytesToKey(const EVP_CIPHER *type, const EVP_MD *md,const unsigned char *salt, const unsigned char *data, int datal, int count, unsigned char *key,unsigned char *iv);8; 9; 1:CTYPE:9; 2:CTYPE:9; 3:bytes=8:92; 4:bytes:91; 5:byte:0; 6:int:93; 7:output:9; 8:output:9; 5<4
# if passlen or saltlen == 0 then treat as string
PKCS5_PBKDF2_HMAC; int PKCS5_PBKDF2_HMAC(const char *pass, int passlen, const unsigned char *salt, int saltlen, int iter,  const EVP_MD *digest, int keylen, unsigned char *out); 8; 9; 1:bytes:91; 2:byte:0; 2<1; 3:bytes:92; 4:byte:0; 4<3; 5:int:93; 6:CTYPE:9; 8:output:9; 7:int:40;
PKCS5_PBKDF2_HMAC_SHA1; int PKCS5_PBKDF2_HMAC_SHA1(const char *pass, int passlen, const unsigned char *salt, int saltlen, int iter, int keylen, unsigned char *out); 7; 9; 1:bytes:91; 2:byte:0; 2<1; 3:bytes:92; 4:byte:0; 4<3; 5:int:93; 7:output:9; 6:int:40;

# libgcrypto
gcry_kdf_derive; gpg_error_t gcry_kdf_derive ( const void *passphrase, size_t passphraselen, int algo, int subalgo, const void *salt, size_t saltlen, unsigned long iterations, size_t keysize, void *keybuffer ); 9; 9; 1:bytes:91; 2:byte:0; 2<1; 3:CTYPE:40; 4:CTYPE:40; 5:bytes:92; 6:byte:0; 6<5; 7:int:93; 8:int:40; 9:output:9;

# kerberos
krb5int_pbkdf2; krb5_error_code krb5int_pbkdf2 (krb5_error_code (*prf)(krb5_keyblock *, krb5_data *, krb5_data *),size_t hlen, const krb5_data *pass, const krb5_data *salt, unsigned long count, const krb5_data *output);6; 9; 3:string:91; 4:string:92; 5:int:93; 6:output:9
krb5_c_string_to_key; krb5_error_code krb5_c_string_to_key(krb5_context context, krb5_enctype enctype, const krb5_data * string, const krb5_data * salt, krb5_keyblock * key); 5; 9; 1:CTX:9; 3:string:91; 4:string:92; 5:output:9
krb5_string_to_key; krb5_error_code krb5_string_to_key(krb5_context context, const krb5_encrypt_block * eblock, krb5_keyblock * keyblock, const krb5_data * data, const krb5_data * salt); 5; 9; 1:CTX:9; 4:string:91; 5:string:92; 5:output:9
krb5_init_creds_set_password; krb5_error_code krb5_init_creds_set_password(krb5_context context, krb5_init_creds_context ctx, const char * password);3; 9; 3:string:91;

# libtomcrypt
pkcs12_kdf; int pkcs12_kdf (int hash_id, const unsigned char *pw, unsigned long pwlen, const unsigned char *salt, unsigned long saltlen, unsigned int iterations, unsigned char purpose, unsigned char *out, unsigned long outlen);9; 9; 1:int:9; 2:bytes:91; 3:byte:0; 3<2; 4:bytes:92; 5:byte:0; 5<4; 6:int:93;

# openBSD
bcrypt_pbkdf; int bcrypt_pbkdf(const char *pass, size_t pass_len, const uint8_t *salt, size_t salt_len, uint8_t *key, size_t key_len, unsigned int rounds);7; 9; 1:bytes:91; 2:byte:0; 2<1; 3:bytes:92; 4:byte:0; 4<3; 7:int:93;

# Kerberos /* String to key */
krb5_string_to_key_data; krb5_error_code krb5_string_to_key_data(krb5_context context, krb5_enctype enctype, krb5_data password, krb5_principal principal, krb5_keyblock *key); 5; 9; 2:string:91; 3:string:92;
krb5_string_to_key_data_salt; krb5_error_code krb5_string_to_key_data_salt(krb5_context context, krb5_enctype enctype, krb5_data password, krb5_salt salt, krb5_keyblock *key); 5; 9; 2:string:91; 3:string:92;
krb5_string_to_key_data_salt_opaque; krb5_error_code krb5_string_to_key_data_salt_opaque(krb5_context context, krb5_enctype enctype, krb5_data password, krb5_salt salt, krb5_data opaque, krb5_keyblock *key); 5; 9; 2:string:91; 3:string:92;
krb5_string_to_key_salt; krb5_error_code krb5_string_to_key_salt(krb5_context context, krb5_enctype enctype, const char *password, krb5_salt salt, krb5_keyblock *key); 5; 9; 2:string:91; 3:string:92;
krb5_string_to_key_salt_opaque; krb5_error_code krb5_string_to_key_salt_opaque(krb5_context context, krb5_enctype enctype, const char *password, krb5_salt salt, krb5_data opaque, krb5_keyblock *key); 5; 9; 2:string:91; 3:string:92;

# return pbkdf2_string_to_key(ktp, string, salt, NULL, params, key,DERIVE_RFC3961, 4096);
krb5int_aes_string_to_key; krb5_error_code krb5int_aes_string_to_key(const struct krb5_keytypes *ktp, const krb5_data *string, const krb5_data *salt, const krb5_data *params, krb5_keyblock *key); 5; 9; 2:string:91; 3:string:92;
krb5int_des_string_to_key; krb5_error_code krb5int_des_string_to_key(const struct krb5_keytypes *ktp, const krb5_data *string, const krb5_data *salt, const krb5_data *params, krb5_keyblock *key); 5; 9; 2:string:91; 3:string:92;
krb5int_arcfour_string_to_key; krb5_error_code krb5int_arcfour_string_to_key(const struct krb5_keytypes *ktp, const krb5_data *string, const krb5_data *salt, const krb5_data *params, krb5_keyblock *key);5; 9; 2:string:91; 3:string:92;
krb5int_dk_string_to_key; krb5_error_code krb5int_dk_string_to_key(const struct krb5_keytypes *enc, const krb5_data *string, const krb5_data *salt, const krb5_data *params, krb5_keyblock *key);5; 9; 2:string:91; 3:string:92;
krb5int_camellia_string_to_key; krb5_error_code krb5int_camellia_string_to_key(const struct krb5_keytypes *enc, const krb5_data *string, const krb5_data *salt, const krb5_data *params, krb5_keyblock *key);5; 9; 2:string:91; 3:string:92;
krb5int_aes2_string_to_key; krb5_error_code krb5int_aes2_string_to_key(const struct krb5_keytypes *enc, const krb5_data *string, const krb5_data *salt, const krb5_data *params, krb5_keyblock *key);5; 9; 2:string:91; 3:string:92;


mbedtls_hkdf; int mbedtls_hkdf( const mbedtls_md_info_t *md, const unsigned char *salt, size_t salt_len, const unsigned char *ikm, size_t ikm_len, const unsigned char *info, size_t info_len, unsigned char *okm, size_t okm_len ); 9; 9; 1:CTYPE:9; 2:bytes:92; 3:int:0; 3<2; 4:bytes:91; 5:byte:0; 5<4; 8:output:9;

# libsodium
# BLAKE2b
crypto_generichashl; int crypto_generichash(unsigned char *out, size_t outlen, const unsigned char *in, unsigned long long inlen, const unsigned char *key, size_t keylen); 6; 9; 5:bytes:91; 6:byte:0; 6<5; 2:int:40;
crypto_generichash_init; int crypto_generichash_init(crypto_generichash_state *state, const unsigned char *key, const size_t keylen, const size_t outlen); 4; 9; 2:bytes:91; 3:byte:0; 3<2; 4:int:40
# SipHash-2-4
crypto_shorthash; int crypto_shorthash(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *k); 4; 9; 4:bytes=24:91;
# PBE Argon2i
crypto_pwhash_str; int crypto_pwhash_str(char out[crypto_pwhash_STRBYTES], const char * const passwd, unsigned long long passwdlen, unsigned long long opslimit, size_t memlimit); 5; 9; 2:string:91;
crypto_pwhash; int crypto_pwhash(unsigned char * const out, unsigned long long outlen, const char * const passwd, unsigned long long passwdlen, const unsigned char * const salt, unsigned long long opslimit, size_t memlimit, int alg); 8; 9; 3:string:91; 4:byte:0; 5:bytes=16:92; 2:int:40;
# BLAKE2B
crypto_kdf_derive_from_key; int crypto_kdf_derive_from_key(unsigned char *subkey, size_t subkey_len, uint64_t subkey_id, const char ctx[crypto_kdf_CONTEXTBYTES],const unsigned char key[crypto_kdf_KEYBYTES]); 5; 9; 5:bytes=32:91;

# crypto ++
DeriveKey; unsigned int DeriveKey (byte *derived, size_t derivedLen, byte purpose, const byte *secret, size_t secretLen, const byte *salt, size_t saltLen, unsigned int iterations, double timeInSeconds=0) const;  9; 9; 4:bytes:91; 5:byte:9; 5<4; 6:bytes:92; 7:byte:0; 7<6; 8:int:93;


mbedtls_pkcs12_pbe_sha1_rc4_128; int mbedtls_pkcs12_pbe_sha1_rc4_128( mbedtls_asn1_buf *pbe_params, int mode, const unsigned char *pwd,  size_t pwdlen, const unsigned char *data, size_t len, unsigned char *output ); 8; 9; 3:bytes:91; 4:byte:0; 4<3; 2:int:9
mbedtls_pkcs12_derivation; int mbedtls_pkcs12_derivation( unsigned char *data, size_t datalen, const unsigned char *pwd, size_t pwdlen, const unsigned char *salt, size_t saltlen, mbedtls_md_type_t md_type, int id, int iterations ); 9; 9; 3:bytes:91; 4:byte:0; 4<3; 5:bytes:92; 6:byte:0; 6<5; 7:CTYPE:1; 9:int:93; 8:int:40;

mbedtls_pkcs12_pbe; int mbedtls_pkcs12_pbe( mbedtls_asn1_buf *pbe_params, int mode, mbedtls_cipher_type_t cipher_type, mbedtls_md_type_t md_type, const unsigned char *pwd,  size_t pwdlen, const unsigned char *data, size_t len, unsigned char *output ); 8; 9; 2:int:9; 3:CTX:9; 4:CTYPE:9; 5:bytes:91; 6:byte:0; 4<5;

mbedtls_pkcs5_pbes2; int mbedtls_pkcs5_pbes2( const mbedtls_asn1_buf *pbe_params, int mode, const unsigned char *pwd,  size_t pwdlen, const unsigned char *data, size_t datalen, unsigned char *output ); 8; 9; 2:int:40; 3:byte:0; 3<2; 3:bytes:91; 4:byte:0; 4<3;

mbedtls_pkcs5_pbkdf2_hmac; int mbedtls_pkcs5_pbkdf2_hmac( mbedtls_md_context_t *ctx, const unsigned char *password, size_t plen, const unsigned char *salt, size_t slen, unsigned int iteration_count, uint32_t key_length, unsigned char *output ); 8; 9; 1:CTX:1; 2:bytes:91; 3:byte:0; 3<2; 4:bytes:92; 5:byte:0; 5<4; 6:int:93;
# PBE
PKCS5_pbe_set0_algor; int PKCS5_pbe_set0_algor(X509_ALGOR *algor, int alg, int iter, const unsigned char *salt, int saltlen); 5; 9; 1:CTX:9; 2:int:40; 3:int:93; 4:bytes:92; 5:byte:0; 5<4;
PKCS5_pbe_set; X509_ALGOR *PKCS5_pbe_set(int alg, int iter, const unsigned char *salt, int saltlen);4; 9; 1:int:40; 2:int:93; 3:bytes:92; 4:byte:0; 4<3;
PKCS5_pbe2_set; X509_ALGOR *PKCS5_pbe2_set(const EVP_CIPHER *cipher, int iter, unsigned char *salt, int saltlen);4; 9; 1:CTX:9; 2:int:93; 3:bytes:92; 4:byte:0; 4<3;
PKCS5_pbe2_set_iv; X509_ALGOR *PKCS5_pbe2_set_iv(const EVP_CIPHER *cipher, int iter, unsigned char *salt, int saltlen, unsigned char *aiv, int prf_nid);4; 9; 1:CTX:9; 2:int:93; 3:bytes:92; 4:byte:0; 4<3;
PKCS5_pbkdf2_set; X509_ALGOR *PKCS5_pbkdf2_set(int iter, unsigned char *salt, int saltlen, int prf_nid, int keylen);5; 9; 1:int:93; 2:bytes:92; 3:byte:0; 3<2;

PKCS5_v2_PBE_keyivgen; int PKCS5_v2_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen, ASN1_TYPE *param, const EVP_CIPHER *c, const EVP_MD *md, int en_de);7; 9; 1:CTX:9; 2:bytes:91; 3:byte:0; 3<2; 5:CTX:9; 6:CTYPE:9; 7:int:40;
PKCS5_v2_PBKDF2_keyivgen; int PKCS5_v2_PBKDF2_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen, ASN1_TYPE *param, const EVP_CIPHER *c, const EVP_MD *md, int en_de);7; 9; 1:CTX:9; 2:bytes:91; 3:byte:0; 3<2; 5:CTX:9; 6:CTYPE:9; 7:int:40;
PKCS5_PBE_keyivgen; int PKCS5_PBE_keyivgen(EVP_CIPHER_CTX *cctx, const char *pass, int passlen, ASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md, int en_de);7; 9; 1:CTX:9; 2:bytes:91; 3:byte:0; 3<2; 5:CTX:9; 6:CTYPE:9; 7:int:40;
PKCS12_PBE_keyivgen; int PKCS12_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen, ASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md, int en_de);7; 9; 1:CTX:9; 2:bytes:91; 3:byte:0; 3<2; 5:CTX:9; 6:CTYPE:9; 7:int:40;

EVP_PBE_CipherInit; int EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen, ASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de); 6; 9; 2:bytes:91; 3:byte:9; 3<2; 5:CTX:9;

# WolfSSL
wc_PBKDF2; int wc_PBKDF2(byte* output, const byte* passwd, int pLen, const byte* salt, int sLen, int iterations, int kLen, int hashType); 8; 9; 2:bytes:91; 3:byte:0; 3<2; 4:bytes:92; 5:byte:0; 5<4; 6:int:93; 8:CTYPE:40; 7:int:40;
wc_PBKDF1; int wc_PBKDF1(byte* output, const byte* passwd, int pLen, const byte* salt, int sLen, int iterations, int kLen, int hashType); 8; 9; 2:bytes:91; 3:byte:0; 3<2; 4:bytes:92; 5:byte:0; 5<4; 6:int:93; 8:CTYPE:40; 7:int:40;
wc_PKCS12_PBKDF; int wc_PKCS12_PBKDF(byte* output, const byte* passwd, int passLen,const byte* salt, int saltLen, int iterations, int kLen, int hashType, int id); 9; 9; 2:bytes:91; 3:byte:0; 3<2; 4:bytes:92; 5:byte:0; 5<4; 6:int:93; 8:CTYPE:9; 9:int:40; 7:int:40;
wc_PKCS12_PBKDF_ex; WOLFSSL_API int wc_PKCS12_PBKDF_ex(byte* output, const byte* passwd,int passLen, const byte* salt, int saltLen, int iterations, int kLen, int hashType, int id, void* heap);10; 9; 2:bytes:91; 3:byte:0; 3<2; 4:bytes:92; 5:byte:0; 5<4; 6:int:93; 8:CTYPE:9; 9:int:40; 7:int:40;
wc_HKDF; int wc_HKDF (int type, const byte *inKey, word32 inKeySz, const byte *salt, word32 saltSz, const byte *info, word32 infoSz, byte *out, word32 outSz);9; 9; 1:CTYPE:9; 2:bytes:92; 3:byte:0; 3<2; 4:bytes:92; 5:byte:0; 5<4; 8:output:9; 9:int:40;


# ---------------------------------------------------------------------------------------------------------------------------- #
# -------------------------------------- HASH FUNCTIONS KEYED ---------------------------------------------------------------- #
# ---------------------------------------------------------------------------------------------------------------------------- #

# OpenSSL libssl and libcrypto  #
#include <openssl/hmac.h>
HMAC; unsigned char *HMAC(const EVP_MD *evp_md, const void *key, int key_len, const unsigned char *d, int n, unsigned char *md, unsigned int *md_len);7;7; 1:CTYPE:7; 2:bytes:72; 3:byte:74; 3<2; 4:bytes:71; 5:byte:0; 5<4; 6:output:7
HMAC_Init_ex; int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int key_len,const EVP_MD *md, ENGINE *impl);5;7; 1:CTX:7; 2:bytes:72; 3:byte:74; 3<2; 4:CTYPE:7;
HMAC_Update; int HMAC_Update(HMAC_CTX *ctx, const unsigned char *data, int len);3;7; 1:CTX:7; 1<2; 1<3; 2:bytes:71; 3:byte:0; 3<2
HMAC_Final; int HMAC_Final(HMAC_CTX *ctx, unsigned char *md, unsigned int *len);3;7; 1:CTX:7; 2:output:7;
# Deprecated
#if OPENSSL_API_COMPAT < 0x10100000L
HMAC_Init; int HMAC_Init(HMAC_CTX *ctx, const void *key, int key_len, const EVP_MD *md);4;7; 1:CTX:7; 2:bytes:72; 3:byte:74; 3<2; 4:CTYPE:7;

#libtomcrypt
hmac_init; int hmac_init (hmac_state * hmac, int hash, const unsigned char * key, unsigned long keylen ); 4; 7; 1:CTX:7; 2:int:40; 3:bytes:72; 4:byte:74; 4<3;

# wolfssl wolfcrypt
# Valid options are: MD5, SHA, SHA256, SHA384, SHA512, BLAKE2B_ID
wc_HmacSetKey; int wc_HmacSetKey (Hmac *, int type, const byte *key, word32 keySz);4; 7; 1:CTX:7; 2:int:7; 3:bytes:72; 4:byte=24:74; 4<3;
HmacSetKey; int HmacSetKey (Hmac *, int type, const byte *key, word32 keySz);4; 7; 1:CTX:7; 2:int:7; 3:bytes:72; 4:byte=24:74; 4<3;
wc_HmacUpdate; int wc_HmacUpdate (Hmac *, const byte *, word32);4; 7; 1:CTX:7; 2:bytes:71; 3:byte:0; 3<2;
HmacUpdate; int HmacUpdate (Hmac *, const byte *, word32);4; 7; 1:CTX:7; 2:bytes:71; 3:byte:0; 3<2;
wc_HmacFinal; int wc_HmacFinal (Hmac *, byte *);2; 7; 1:CTX:7; 2:output:7;
HmacFinal; int HmacFinal (Hmac *, byte *);2; 7; 1:CTX:7; 2:output:7;

# libgcrypt
gcry_md_setkey; gcry_error_t gcry_md_setkey (gcry_md_hd_t h, const void *key, size_t keylen); 3; 7; 1:CTX:7; 2:bytes:72; 3:byte:74; 3<2;

mbedtls_md_hmac_starts; int mbedtls_md_hmac_starts( mbedtls_md_context_t *ctx, const unsigned char *key, size_t keylen );3; 7; 1:CTX:7; 2:bytes:71; 3:byte:0; 3<2;

mbedtls_md_hmac_update; uint mbedtls_md_hmac_update( mbedtls_md_context_t *ctx, const unsigned char *input, size_t ilen );3; 7; 1:CTX:7; 2:bytes:71; 3:byte:0; 3<2;
mbedtls_md_hmac_finish; int mbedtls_md_hmac_finish( mbedtls_md_context_t *ctx, unsigned char *output); 2; 7; 1:CTX:7; 1:output:7;

mbedtls_md_hmac; int mbedtls_md_hmac( const mbedtls_md_info_t *md_info, const unsigned char *key, size_t keylen, const unsigned char *input, size_t ilen, unsigned char *output );6; 7; 1:CTX:7; 2:bytes:72; 3:byte:74; 3<2; 4:bytes:71; 5:byte:0; 5<4; 6:output:7;

# libsodium
# HMAC-SHA512-256 -> 32 bytes
crypto_auth; int crypto_auth(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *k); 4; 7; 4:bytes=32:72;
crypto_auth_verify; int crypto_auth_verify(const unsigned char *h, const unsigned char *in, unsigned long long inlen, const unsigned char *k); 4; 7; 4:bytes=32:72;

#CMAC_Init
CMAC_Init; int CMAC_Init(CMAC_CTX *ctx, const void *key, size_t key_len, const EVP_CIPHER *cipher, ENGINE *impl); 5; 7; 1:CTX:7; 2:bytes:72; 3:byte:0; 3<2; 4:CTYPE:7;
CMAC_Update; int CMAC_Update(CMAC_CTX *ctx, const void *in_data, size_t in_len); 3; 7; 1:CTX:1; 1:bytes:71; 2:byte:0; 2<1;
CMAC_Final; int CMAC_Final(CMAC_CTX *ctx, unsigned char *out_mac, size_t *out_len); 3; 7; 1:CTX:1; 2:output:7;

EVP_PKEY_new_CMAC_key; EVP_PKEY *EVP_PKEY_new_CMAC_key(ENGINE *e, const unsigned char *priv, size_t len, const EVP_CIPHER *cipher); 4; 7; 2:bytes:72; 3:byte:0; 3<2; 4:CTYPE:7;
EVP_PKEY_new_mac_key; EVP_PKEY *EVP_PKEY_new_mac_key(int type, ENGINE *e, const unsigned char *key, int keylen);4; 7; 3:bytes:72; 4:byte:0; 4<3;

#/* Compute an HMAC using the provided hash function, key, and data, storing the
# * result into output (caller-allocated). */
krb5int_hmac; krb5_error_code krb5int_hmac(const struct krb5_hash_provider *hash, krb5_key key, const krb5_crypto_iov *data, size_t num_data, krb5_data *output); 5; 7; 2:string:72;

# add post rules
gcry_mac_setkey; gcry_error_t gcry_mac_setkey (gcry_mac_hd_t h, const void *key, size_t keylen); 3; 7; 1:CTX:1; 2:bytes:72; 3:byte:74; 3<2;

wc_GmacSetKey; WOLFSSL_API int wc_GmacSetKey(Gmac* gmac, const byte* key, word32 len); 3; 7; 1:CTX:1; 2:bytes:72; 3:byte:0; 3<2;
# This function generates the Gmac hash of the authIn input and stores the result in the authTag buffer.
# After running wc_GmacUpdate, one should compare the generated authTag to a known authentication tag to verify the authenticity of a message.
wc_GmacUpdate; int 	wc_GmacUpdate (Gmac *gmac, const byte *iv, word32 ivSz, const byte *authIn, word32 authInSz, byte *authTag, word32 authTagSz);7;7; 1:CTX:1; 2:bytes:22; 3:byte:0; 3<2; 4:bytes:24; 5:byte:0; 5<4; 6:output:2;


# ---------------------------------------------------------------------------------------------------------------------------- #
# -------------------------------------- Authenticated Encryption / MAC (2) -------------------------------------------------- #
# ---------------------------------------------------------------------------------------------------------------------------- #
# TOOD where is authenticated IV or key is changes to authenticated and not symmetric key??
#AES GCM
EVP_aes_128_gcm; EVP_CIPHER* EVP_aes_128_gcm(void); 0; 2; 0:none:2
EVP_aes_192_gcm; EVP_CIPHER* EVP_aes_192_gcm(void); 0; 2; 0:none:2
EVP_aes_256_gcm; EVP_CIPHER* EVP_aes_256_gcm(void); 0; 2; 0:none:2

# AES Counter with CBC-MAC Mode (CCM) for 128, 192 and 256 bit keys respectively.
EVP_aes_128_ccm; EVP_CIPHER* EVP_aes_128_ccm(void); 0; 2; 0:none:2
EVP_aes_192_ccm; EVP_CIPHER* EVP_aes_192_ccm(void); 0; 2; 0:none:2
EVP_aes_256_ccm; EVP_CIPHER* EVP_aes_256_ccm(void); 0; 2; 0:none:2

#OCB mode
EVP_aes_128_ocb; EVP_CIPHER* EVP_aes_128_ocb(void); 0; 2; 0:none:2
EVP_aes_192_ocb; EVP_CIPHER* EVP_aes_192_ocb(void); 0; 2; 0:none:2
EVP_aes_256_ocb; EVP_CIPHER* EVP_aes_256_ocb(void); 0; 2; 0:none:2

# Authenticated encryption with AES in CBC mode using SHA-1 as HMAC, with keys of 128 and 256 bits length respectively.
# The authentication tag is 160 bits long.
EVP_aes_128_cbc_hmac_sha1; EVP_CIPHER * EVP_aes_128_cbc_hmac_sha1(void); 0; 2; 0:none:2
EVP_aes_256_cbc_hmac_sha1; EVP_CIPHER * EVP_aes_256_cbc_hmac_sha1(void); 0; 2; 0:none:2
EVP_aes_128_cbc_hmac_sha256; EVP_CIPHER * EVP_aes_128_cbc_hmac_sha256(void); 0; 2; 0:none:2
EVP_aes_256_cbc_hmac_sha256; EVP_CIPHER * EVP_aes_256_cbc_hmac_sha256(void); 0; 2; 0:none:2

# Like EVP_chacha20() the key is 256 bits and the IV is 96 bits.
# This supports additional authenticated data (AAD) and produces a 128 bit authentication tag.
EVP_chacha20_poly1305; EVP_CIPHER* EVP_chacha20_poly1305(); 0; 2; 0:none:2

EVP_aead_aes_128_gcm; const EVP_AEAD *EVP_aead_aes_128_gcm(void); 0; 2; 0:none:2
EVP_aead_aes_192_gcm; const EVP_AEAD *EVP_aead_aes_192_gcm(void); 0; 2; 0:none:2
EVP_aead_aes_256_gcm; const EVP_AEAD *EVP_aead_aes_256_gcm(void); 0; 2; 0:none:2
EVP_aead_xchacha20_poly1305; const EVP_AEAD *EVP_aead_xchacha20_poly1305(void); 0; 2; 0:none:2

EVP_aead_chacha20_poly1305; undefined EVP_aead_chacha20_poly1305(); 0; 2; 0:none:2

# authenticated encryption with additional authenticated data
EVP_AEAD_CTX_init; int EVP_AEAD_CTX_init(EVP_AEAD_CTX *ctx, const EVP_AEAD *aead, const unsigned char *key, size_t key_len, size_t tag_len, ENGINE *impl); 6; 2; 1:CTX:2; 2:CTYPE:2; 3:bytes:21; 4:byte:0; 4<3; 5:int:2;
EVP_AEAD_CTX_open; int EVP_AEAD_CTX_open(const EVP_AEAD_CTX *ctx, unsigned char *out, size_t *out_len, size_t max_out_len, const unsigned char *nonce, size_t nonce_len, const unsigned char *in, size_t in_len, const unsigned char *ad, size_t ad_len); 10; 2; 1:CTX:2; 2:output:2; 3:bytes:21; 4:byte:0; 5:bytes:22; 6:byte:0; 6<5; 7:bytes:23; 8:byte:0; 8<7; 9:bytes:24; 10:byte:0; 10<9
EVP_AEAD_CTX_seal; int EVP_AEAD_CTX_seal(const EVP_AEAD_CTX *ctx, unsigned char *out, size_t *out_len, size_t max_out_len, const unsigned char *nonce, size_t nonce_len, const unsigned char *in, size_t in_len, const unsigned char *ad, size_t ad_len); 10; 2; 1:CTX:2; 2:output:2; 3:bytes:21; 4:byte:0; 5:bytes:22; 6:byte:0; 6<5; 7:bytes:23; 8:byte:0; 8<7; 9:bytes:24; 10:byte:0; 10<9

# wolfssl wolfcrypt
# This function is used to set the key for AES GCM (Galois/Counter Mode).
# It initializes an AES object with the given key...
wc_AesGcmSetKey; int wc_AesGcmSetKey (Aes *aes, const byte *key, word32 len);3; 1; 1:CTX:2; 2:bytes=16=24=32:21; 3:byte:0; 3<2

# This function encrypts the input message, held in the buffer in, and stores the resulting cipher text in the output buffer out.
# It requires a new iv (initialization vector) for each call to encrypt.
# It also encodes the input authentication vector, authIn, into the authentication tag, authTag. More...
wc_AesGcmEncrypt; int 	wc_AesGcmEncrypt (Aes *aes, byte *out, const byte *in, word32 sz, const byte *iv, word32 ivSz, byte *authTag, word32 authTagSz, const byte *authIn, word32 authInSz);10; 2; 1:CTX:2; 2:output:2; 3:bytes:23; 4:byte:0; 4<3; 5:bytes=12=16:22; 6:byte:0; 6<5; 7:output:2; 9:bytes:24; 10:byte:0; 9<8;

# This function decrypts the input cipher text, held in the buffer in, and stores the resulting message text in the output buffer out.
# It also checks the input authentication vector, authIn, against the supplied authentication tag, authTag.
wc_AesGcmDecrypt; int 	wc_AesGcmDecrypt (Aes *aes, byte *out, const byte *in, word32 sz, const byte *iv, word32 ivSz, const byte *authTag, word32 authTagSz, const byte *authIn, word32 authInSz); 10; 2; 1:CTX:2; 2:output:2; 3:bytes:23; 4:byte:0; 4<3; 5:bytes=12=16:22; 6:byte:0; 7:bytes:25; 8:byte:0; 8<7; 9:bytes:24; 10:byte:0; 9<8;

# This function sets the key for an AES object using CCM (Counter with CBC-MAC).
# It takes a pointer to an AES structure and initializes it with supplied key.
wc_AesCcmSetKey; int 	wc_AesCcmSetKey (Aes *aes, const byte *key, word32 keySz);3; 1; 1:CTX:1; 2:bytes=16=24=32:21; 3:byte:0; 3<2

# This function encrypts the input message, in, into the output buffer, out, using CCM (Counter with CBC-MAC).
# It subsequently calculates and stores the authorization tag, authTag, from the authIn input.
wc_AesCcmEncrypt;  int 	wc_AesCcmEncrypt (Aes *aes, byte *out, const byte *in, word32 inSz, const byte *nonce, word32 nonceSz, byte *authTag, word32 authTagSz, const byte *authIn, word32 authInSz);10; 2; 1:CTX:2; 2:output:2; 3:bytes:23; 4:byte:0; 4<3; 5:bytes=12=16:22; 6:byte:0; 6<5; 7:output:2; 9:bytes:24; 10:byte:0; 9<8;

# This function decrypts the input cipher text, in, into the output buffer, out, using CCM (Counter with CBC-MAC).
# It subsequently calculates the authorization tag, authTag, from the authIn input.
# If the authorization tag is invalid, it sets the output buffer to zero and returns the error: AES_CCM_AUTH_E.
wc_AesCcmDecrypt;  int 	wc_AesCcmDecrypt (Aes *aes, byte *out, const byte *in, word32 inSz, const byte *nonce, word32 nonceSz, const byte *authTag, word32 authTagSz, const byte *authIn, word32 authInSz); 10; 2; 1:CTX:2; 2:output:2; 3:bytes:23; 4:byte:0; 4<3; 5:bytes=12=16:22; 6:byte:0; 7:bytes:25; 8:byte:0; 8<7; 9:bytes:24; 10:byte:0; 9<8;

mbedtls_ccm_setkey; int mbedtls_ccm_setkey( mbedtls_ccm_context *ctx,  mbedtls_cipher_id_t cipher, const unsigned char *key,  unsigned int keybits ); 4; 2; 1:CTX:2; 2:CTYPE:2; 3:bytes:21; 4:bit:0; 4<3;


mbedtls_ccm_encrypt_and_tag; int mbedtls_ccm_encrypt_and_tag( mbedtls_ccm_context *ctx, size_t length,  const unsigned char *iv, size_t iv_len,  const unsigned char *add, size_t add_len, const unsigned char *input, unsigned char *output,  unsigned char *tag, size_t tag_len ); 10; 2; 1:CTX:2; 2:bytes:0; 3:bytes=7=8=9=10=11=12=13:22; 4:byte:0; 4<3; 5:bytes:24; 6:byte:0; 6<5; 7:bytes:23; 8:output:2; 2<7; 9:bytes:25; 10:byte:0; 10<9;
mbedtls_ccm_star_encrypt_and_tag; int mbedtls_ccm_star_encrypt_and_tag( mbedtls_ccm_context *ctx, size_t length, const unsigned char *iv, size_t iv_len, const unsigned char *add, size_t add_len, const unsigned char *input, unsigned char *output, unsigned char *tag, size_t tag_len ); 10; 2; 1:CTX:2; 2:bytes:0; 3:bytes=7=8=9=10=11=12=13:22; 4:byte:0; 4<3; 5:bytes:24; 6:byte:0; 6<5; 7:bytes:23; 8:output:2; 2<7; 9:bytes:25; 10:byte:0; 10<9;
mbedtls_ccm_auth_decrypt; int mbedtls_ccm_auth_decrypt( mbedtls_ccm_context *ctx, size_t length, const unsigned char *iv, size_t iv_len, const unsigned char *add, size_t add_len, const unsigned char *input, unsigned char *output, const unsigned char *tag, size_t tag_len ); 10; 2; 1:CTX:2; 2:bytes:0; 3:bytes=7=8=9=10=11=12=13:22; 4:byte:0; 4<3; 5:bytes:24; 6:byte:0; 6<5; 7:bytes:23; 8:output:2; 2<7; 9:bytes:25; 10:byte:0; 10<9;
mbedtls_ccm_star_auth_decrypt; int mbedtls_ccm_star_auth_decrypt( mbedtls_ccm_context *ctx, size_t length, const unsigned char *iv, size_t iv_len, const unsigned char *add, size_t add_len, const unsigned char *input, unsigned char *output, const unsigned char *tag, size_t tag_len );  10; 2; 1:CTX:2; 2:bytes:0; 3:bytes=7=8=9=10=11=12=13:22; 4:byte:0; 4<3; 5:bytes:24; 6:byte:0; 6<5; 7:bytes:23; 8:output:2; 2<7; 9:bytes:25; 10:byte:0; 10<9;


mbedtls_cipher_auth_encrypt; int mbedtls_cipher_auth_encrypt( mbedtls_cipher_context_t *ctx, const unsigned char *iv, size_t iv_len, const unsigned char *ad, size_t ad_len, const unsigned char *input, size_t ilen, unsigned char *output, size_t *olen, unsigned char *tag, size_t tag_len ); 11; 2; 1:CTX:2; 2:bytes=7=8=9=10=11=12=13:22; 3:byte:0; 3<2; 4:bytes:24; 5:byte:0; 5<4; 6:bytes:23; 7:bytes:0; 7<6; 8:output:2; 10:bytes:25; 11:byte:0; 11<10;
mbedtls_cipher_auth_decrypt; int mbedtls_cipher_auth_decrypt( mbedtls_cipher_context_t *ctx,const unsigned char *iv, size_t iv_len, const unsigned char *ad, size_t ad_len, const unsigned char *input, size_t ilen, unsigned char *output, size_t *olen, const unsigned char *tag, size_t tag_len ); 11; 2; 1:CTX:2; 2:bytes=7=8=9=10=11=12=13:22; 3:byte:0; 3<2; 4:bytes:24; 5:byte:0; 5<4; 6:bytes:23; 7:bytes:0; 7<6; 8:output:2; 10:bytes:25; 11:byte:0; 11<10;

mbedtls_gcm_setkey; int mbedtls_gcm_setkey( mbedtls_gcm_context *ctx, mbedtls_cipher_id_t cipher, const unsigned char *key, unsigned int keybits ); 4; 2; 1:CTX:2; 2:int:2; 3:bytes:21; 4:bit:0; 4<3;
mbedtls_gcm_crypt_and_tag; int mbedtls_gcm_crypt_and_tag( mbedtls_gcm_context *ctx, int mode, size_t length, const unsigned char *iv, size_t iv_len, const unsigned char *add, size_t add_len,  const unsigned char *input,unsigned char *output, size_t tag_len, unsigned char *tag ); 11; 2; 1:CTX:2; 2:int:1; 3:byte:0; 4:bytes:22; 5:byte:0; 5<4; 6:bytes:24; 7:bytes:0; 7<6; 8:bytes:23; 3<8; 9:output:2; 11:bytes:25; 10:byte:0; 10<11;

mbedtls_gcm_auth_decrypt; int mbedtls_gcm_auth_decrypt( mbedtls_gcm_context *ctx, size_t length, const unsigned char *iv, size_t iv_len, const unsigned char *add, size_t add_len, const unsigned char *tag, size_t tag_len, const unsigned char *input, unsigned char *output ); 10; 2; 1:CTX:2; 2:byte:0; 3:bytes:22; 4:byte:0; 4<3; 5:bytes:24; 6:byte:0; 6<5; 7:bytes:25; 8:byte:0; 8<7; 9:bytes:23; 2<9; 10:output:2;

mbedtls_gcm_starts; int mbedtls_gcm_starts( mbedtls_gcm_context *ctx, int mode, const unsigned char *iv, size_t iv_len, const unsigned char *add, size_t add_len );6; 2; 1:CTX:2; 2:int:1; 3:bytes:22; 4:byte:0; 4<3; 5:bytes:24; 6:byte:0; 6<5;
mbedtls_gcm_update; int mbedtls_gcm_update( mbedtls_gcm_context *ctx, size_t length, const unsigned char *input, unsigned char *output ); 4; 2; 1:CTX:1; 2:byte:0; 3:bytes:23; 2<3;
mbedtls_gcm_finish; int mbedtls_gcm_finish( mbedtls_gcm_context *ctx, unsigned char *tag, size_t tag_len ); 3; 2; 1:CTX:1;

#l ibsodium
# Encryption: XSalsa20 stream cipher
# Authentication: Poly1305 MAC
crypto_secretbox_easy; int crypto_secretbox_easy(unsigned char *c, const unsigned char *m, unsigned long long mlen, const unsigned char *n, const unsigned char *k);5; 2; 4:bytes=24:22; 5:bytes=32:21;
crypto_secretbox_open_easy; int crypto_secretbox_open_easy(unsigned char *m, const unsigned char *c, unsigned long long clen, const unsigned char *n, const unsigned char *k); 5; 2; 14:bytes=24:22; 5:bytes=32:21;
crypto_secretbox_detached; int crypto_secretbox_detached(unsigned char *c, unsigned char *mac, const unsigned char *m, unsigned long long mlen, const unsigned char *n, const unsigned char *k); 6; 2; 5:bytes=24:22; 6:bytes=32:21;
crypto_secretbox_open_detached; int crypto_secretbox_open_detached(unsigned char *m, const unsigned char *c, const unsigned char *mac, unsigned long long clen, const unsigned char *n, const unsigned char *k); 6; 2; 5:bytes=24:22; 6:bytes=32:21;

crypto_secretstream_xchacha20poly1305_init_pull; int crypto_secretstream_xchacha20poly1305_init_pull   (crypto_secretstream_xchacha20poly1305_state *state,    const unsigned char header[crypto_secretstream_xchacha20poly1305_HEADERBYTES],    const unsigned char k[crypto_secretstream_xchacha20poly1305_KEYBYTES]); 3; 2; 3:bytes=32:21;
crypto_secretstream_xchacha20poly1305_init_push; int crypto_secretstream_xchacha20poly1305_init_push   (crypto_secretstream_xchacha20poly1305_state *state,    unsigned char header[crypto_secretstream_xchacha20poly1305_HEADERBYTES],    const unsigned char k[crypto_secretstream_xchacha20poly1305_KEYBYTES]); 3; 2; 3:bytes=32:21;

# ---------------------------------------------------------------------------------------------------------------------------- #
# -------------------------------------- Public Key Cryptography (3) -------------------------------------------------------- #
# ---------------------------------------------------------------------------------------------------------------------------- #

#/* Padding types */

# OpenSSL rsa padding
# define RSA_PKCS1_PADDING       1
# define RSA_SSLV23_PADDING      2
# define RSA_NO_PADDING          3
# define RSA_PKCS1_OAEP_PADDING  4
# define RSA_X931_PADDING        5
# /* EVP_PKEY_ only */
# define RSA_PKCS1_PSS_PADDING   6
# define RSA_PKCS1_PADDING_SIZE  11

RSA_public_encrypt; int RSA_public_encrypt(int flen, unsigned char *from,  unsigned char *to, RSA *rsa, int padding); 5; 3; 5:int:31; 4:CTX:3;
RSA_private_decrypt; int RSA_private_decrypt(int flen, unsigned char *from, unsigned char *to, RSA *rsa, int padding); 5; 3; 5:int:31; 4:CTX:3;
RSA_private_encrypt; int RSA_private_encrypt(int flen, unsigned char *from, unsigned char *to, RSA *rsa, int padding); 5; 3; 5:int:31; 4:CTX:3;
RSA_public_decrypt; int RSA_public_decrypt(int flen, unsigned char *from,  unsigned char *to, RSA *rsa, int padding); 5; 3; 5:int:31; 4:CTX:3;
EVP_PKEY_CTX_set_rsa_padding; int EVP_PKEY_CTX_set_rsa_padding(EVP_PKEY_CTX *ctx, int pad);2; 3; 1:CTX:3; 2:int:31;

# WolfSSL padding types
#define WC_RSA_PKCSV15_PAD 0
#define WC_RSA_OAEP_PAD    1
#define WC_RSA_PSS_PAD     2
#define WC_RSA_NO_PAD      3
wc_RsaPublicEncrypt_ex; int  wc_RsaPublicEncrypt_ex(const byte* in, word32 inLen, byte* out, word32 outLen, RsaKey* key, WC_RNG* rng, int type, enum wc_HashType hash, int mgf, byte* label, word32 lableSz);11; 3; 7:int:31
wc_RsaPrivateDecrypt_ex; int  wc_RsaPrivateDecrypt_ex(const byte* in, word32 inLen, byte* out, word32 outLen, RsaKey* key, int type, enum wc_HashType hash, int mgf, byte* label, word32 lableSz);10; 3; 6:int:31
wc_RsaPrivateDecryptInline_ex; int  wc_RsaPrivateDecryptInline_ex(byte* in, word32 inLen, byte** out, RsaKey* key, int type, enum wc_HashType hash, int mgf, byte* label, word32 lableSz);9; 3; 5:int:31
wc_RsaDirect; int wc_RsaDirect(byte* in, word32 inLen, byte* out, word32* outSz,  RsaKey* key, int type, WC_RNG* rng); 7; 3; 6:int:31
# no padding
wc_RsaPublicEncrypt; WOLFSSL_API int  wc_RsaPublicEncrypt(const byte* in, word32 inLen, byte* out, word32 outLen, RsaKey* key, WC_RNG* rng);6; 3; 0:none:32
wc_RsaPrivateDecrypt; WOLFSSL_API int  wc_RsaPrivateDecrypt(const byte* in, word32 inLen, byte* out, word32 outLen, RsaKey* key);5; 2; 0:none:32

# PolarSSL/mbedSSL
# Generic wrapper to perform a PKCS#1 encryption using the mode from the context.
rsa_pkcs1_decrypt; int rsa_pkcs1_decrypt( mbedtls_rsa_context *ctx, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, int mode, size_t *olen, const unsigned char *input, unsigned char *output, size_t output_max_len);8; 3; 0:none:32
mbedtls_rsa_pkcs1_decrypt; int mbedtls_rsa_pkcs1_decrypt( mbedtls_rsa_context *ctx, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, int mode, size_t *olen, const unsigned char *input, unsigned char *output, size_t output_max_len);8; 3; 0:none:32

rsa_pkcs1_encrypt; int rsa_pkcs1_encrypt( mbedtls_rsa_context *ctx, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, int mode, size_t ilen, const unsigned char *input, unsigned char *output );8; 3; 1:CTX:31
mbedtls_rsa_pkcs1_encrypt; int mbedtls_rsa_pkcs1_encrypt( mbedtls_rsa_context *ctx, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, int mode, size_t ilen, const unsigned char *input, unsigned char *output );8; 3; 1:CTX:31

# Perform a PKCS#1 v1.5 encryption (RSAES-PKCS1-v1_5-ENCRYPT)
rsa_rsaes_pkcs1_v15_encrypt; int rsa_rsaes_pkcs1_v15_encrypt( mbedtls_rsa_context *ctx, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, int mode, size_t ilen, const unsigned char *input, unsigned char *output ); 7; 3; 0:none:32;
mbedtls_rsa_rsaes_pkcs1_v15_encrypt; int mbedtls_rsa_rsaes_pkcs1_v15_encrypt( mbedtls_rsa_context *ctx, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, int mode, size_t ilen, const unsigned char *input, unsigned char *output ); 7; 3; 0:none:32;

rsa_rsaes_pkcs1_v15_decrypt ; int rsa_rsaes_pkcs1_v15_decrypt( mbedtls_rsa_context *ctx, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, int mode, size_t *olen,  const unsigned char *input, unsigned char *output, size_t output_max_len ); 8; 3; 0:none:32;
mbedtls_rsa_rsaes_pkcs1_v15_decrypt; int mbedtls_rsa_rsaes_pkcs1_v15_decrypt( mbedtls_rsa_context *ctx, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, int mode, size_t *olen,  const unsigned char *input, unsigned char *output, size_t output_max_len ); 8; 3; 0:none:32;

mbedtls_rsa_set_padding; void mbedtls_rsa_set_padding( mbedtls_rsa_context *ctx, int padding, int hash_id ); 3; 3; 1:CTX:3; 2:int:31; 3:int:40;
mbedtls_rsa_init; void mbedtls_rsa_init (mbedtls_rsa_context *  ctx, int padding, int hash_id); 	3; 3; 1:CTX:3; 2:int:31;

# Perform a PKCS#1 v2.1 OAEP encryption (RSAES-OAEP-ENCRYPT)
mbedtls_rsa_rsaes_oaep_encrypt; int mbedtls_rsa_rsaes_oaep_encrypt( mbedtls_rsa_context *ctx, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, int mode, const unsigned char *label, size_t label_len, size_t ilen, const unsigned char *input, unsigned char *output ); 0; 3; 0:none:31;
mbedtls_rsa_rsaes_oaep_decrypt; int mbedtls_rsa_rsaes_oaep_decrypt( mbedtls_rsa_context *ctx, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,  int mode,  const unsigned char *label, size_t label_len,  size_t *olen, const unsigned char *input, unsigned char *output, size_t output_max_len ); 0; 3; 0:none:31;


#rsa_pkcs1_sign;  int rsa_pkcs1_sign( mbedtls_rsa_context *ctx, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, int mode, mbedtls_md_type_t md_alg, unsigned int hashlen, const unsigned char *hash, unsigned char *sig );8; 3; 0:none:32
#mbedtls_rsa_pkcs1_sign; int mbedtls_rsa_pkcs1_sign( mbedtls_rsa_context *ctx, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, int mode, mbedtls_md_type_t md_alg, unsigned int hashlen, const unsigned char *hash, unsigned char *sig );8; 3; 0:none:32
#rsa_pkcs1_verify ;int rsa_pkcs1_verify( mbedtls_rsa_context *ctx, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, int mode, mbedtls_md_type_t md_alg, unsigned int hashlen, const unsigned char *hash,  const unsigned char *sig );8; 3; 0:none:32
#mbedtls_rsa_pkcs1_verify; int mbedtls_rsa_pkcs1_verify( mbedtls_rsa_context *ctx, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, int mode, mbedtls_md_type_t md_alg, unsigned int hashlen, const unsigned char *hash,  const unsigned char *sig );8; 3; 0:none:32
#rsa_rsassa_pkcs1_v15_sign ; int rsa_rsassa_pkcs1_v15_sign( mbedtls_rsa_context *ctx, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, int mode, mbedtls_md_type_t md_alg, unsigned int hashlen, const unsigned char *hash, unsigned char *sig ); 8; 3; 0:none:31;
#mbedtls_rsa_rsassa_pkcs1_v15_sign;int mbedtls_rsa_rsassa_pkcs1_v15_sign( mbedtls_rsa_context *ctx, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, int mode, mbedtls_md_type_t md_alg, unsigned int hashlen, const unsigned char *hash, unsigned char *sig ); 8; 3; 0:none:31;
#rsa_rsassa_pkcs1_v15_verify ;int rsa_rsassa_pkcs1_v15_verify( mbedtls_rsa_context *ctx, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, int mode, mbedtls_md_type_t md_alg, unsigned int hashlen, const unsigned char *hash, const unsigned char *sig ); 8; 3; 0:none:31;
#mbedtls_rsa_rsassa_pkcs1_v15_verify;int mbedtls_rsa_rsassa_pkcs1_v15_verify( mbedtls_rsa_context *ctx, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, int mode, mbedtls_md_type_t md_alg, unsigned int hashlen, const unsigned char *hash, const unsigned char *sig ); 8; 3; 0:none:31;
# PSS
#mbedtls_rsa_rsassa_pss_sign; int mbedtls_rsa_rsassa_pss_sign( mbedtls_rsa_context *ctx, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, int mode, mbedtls_md_type_t md_alg, unsigned int hashlen, const unsigned char *hash, unsigned char *sig ); 0; 3; 0:none:31;

# padding add for encrypt/decrypt RSA
RSA_padding_add_PKCS1_type_1; int RSA_padding_add_PKCS1_type_1(unsigned char *to, int tlen, const unsigned char *f, int fl); 3; 3; 0:none:32;
RSA_padding_add_PKCS1_type_2; int RSA_padding_add_PKCS1_type_2(unsigned char *to, int tlen, const unsigned char *f, int fl); 3 ;3; 0:none:32;
RSA_padding_add_PKCS1_OAEP; int RSA_padding_add_PKCS1_OAEP(unsigned char *to, int tlen, const unsigned char *f, int fl, const unsigned char *p, int pl); 6; 3; 0:none:31
RSA_padding_add_PKCS1_OAEP_mgf1; int RSA_padding_add_PKCS1_OAEP_mgf1(unsigned char *to, int tlen, const unsigned char *f, int fl, const unsigned char *p, int pl, const EVP_MD *md, const EVP_MD *mgf1md); 8; 3; 0:none:31;
RSA_padding_add_SSLv23; int RSA_padding_add_SSLv23(unsigned char *to, int tlen, const unsigned char *f, int fl); 3; 3; 0:none:32;
RSA_padding_add_none; int RSA_padding_add_none(unsigned char *to,int tlen, const unsigned char *f,int fl); 3; 3; 0:none:32
RSA_padding_add_X931; int RSA_padding_add_X931(unsigned char *to,int tlen, const unsigned char *f,int fl); 0; 3; 0:none:31
# PKCS#1v2.1
#PKCS1_MGF1; int PKCS1_MGF1(unsigned char *mask, long len, const unsigned char *seed, long seedlen, const EVP_MD *dgst); 4; 3; 0:none:31
#RSA_padding_add_PKCS1_PSS; int RSA_padding_add_PKCS1_PSS(RSA *rsa, unsigned char *EM, const unsigned char *mHash, const EVP_MD *Hash, int sLen); 0; 3; 0:none:31
#RSA_padding_add_PKCS1_PSS_mgf1; int RSA_padding_add_PKCS1_PSS_mgf1(RSA *rsa, unsigned char *EM, const unsigned char *mHash, const EVP_MD *Hash, const EVP_MD *mgf1Hash, int sLen); 0; 3; 0:none:31

#EVP_PKEY_CTX_set_rsa_mgf1_md; int EVP_PKEY_CTX_set_rsa_mgf1_md(EVP_PKEY_CTX *ctx, const EVP_MD *md); 2; 3; 1:CTX:3; 2:CTYPE:3;
#EVP_PKEY_CTX_set_rsa_oaep_md; int EVP_PKEY_CTX_set_rsa_oaep_md(EVP_PKEY_CTX *ctx, const EVP_MD *md); 2; 3; 1:CTX:3; 2:CTYPE:3;

# ------------------------------ Χ509 ----------------------
# OpenSSL
X509_digest; int X509_digest(const X509 *data, const EVP_MD *type, unsigned char *md, unsigned int *len); 4; 3; 2:CTYPE:33;
X509_ALGOR_set_md; void X509_ALGOR_set_md(X509_ALGOR *alg, const EVP_MD *md); 2; 3; 2:CTYPE:33

X509_sign; int X509_sign(X509 *x, EVP_PKEY *pkey, const EVP_MD *md); 3; 3; 3:CTYPE:33
X509_REQ_sign; int X509_REQ_sign(X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md); 3; 3; 3:CTYPE:33
X509_CRL_sign; int X509_CRL_sign(X509_CRL *x, EVP_PKEY *pkey, const EVP_MD *md); 3; 3; 3:CTYPE:33

X509_CRL_digest; int X509_CRL_digest(const X509_CRL *data, const EVP_MD *type, unsigned char *md, unsigned int *len);4; 3; 2:CTYPE:33
X509_pubkey_digest; int X509_pubkey_digest(const X509 *data, const EVP_MD *type, unsigned char *md, unsigned int *len);4; 3; 2:CTYPE:33
X509_REQ_digest; int X509_REQ_digest(const X509_REQ *data, const EVP_MD *type, unsigned char *md, unsigned int *len);4; 3; 2:CTYPE:33
X509_NAME_digest; int X509_NAME_digest(const X509_NAME *data, const EVP_MD *type, unsigned char *md, unsigned int *len);4; 3; 2:CTYPE:33
PKCS7_ISSUER_AND_SERIAL_digest; int PKCS7_ISSUER_AND_SERIAL_digest(PKCS7_ISSUER_AND_SERIAL *data, const EVP_MD *type, unsigned char *md, unsigned int *len);4; 3; 2:CTYPE:33

# gnuTLS
gnutls_x509_crt_privkey_sign; int gnutls_x509_crt_privkey_sign(gnutls_x509_crt_t crt, gnutls_x509_crt_t issuer, gnutls_privkey_t issuer_key, gnutls_digest_algorithm_t dig, unsigned int flags);6; 3; 5:int:33
gnutls_x509_crt_get_fingerprint; int gnutls_x509_crt_get_fingerprint(gnutls_x509_crt_t cert, gnutls_digest_algorithm_t algo, void *buf, size_t * buf_size);4; 3; 2:CTYPE:33

# Digital Signatures!
# sign/verify
EVP_DigestSignInit; int EVP_DigestSignInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,  const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey); 5; 3; 1:CTX:35; 2:CTX:3; 3:CTYPE:35;
EVP_DigestSignUpdate; int EVP_DigestSignUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt); 3; 3; 1:CTX:3;
EVP_DigestSignFinal; int EVP_DigestSignFinal(EVP_MD_CTX *ctx, unsigned char *sig, size_t *siglen); 3; 3; 1:CTX:3;

EVP_DigestVerifyInit; int EVP_DigestVerifyInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx, const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey); 5; 3; 1:CTX:35; 2:CTX:3; 3:CTYPE:35;
EVP_DigestVerifyUpdate; int EVP_DigestVerifyUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt); 3; 3; 1:CTX:3;
EVP_DigestVerifyFinal; int EVP_DigestVerifyFinal(EVP_MD_CTX *ctx, const unsigned char *sig, size_t siglen); 3; 3; 1:CTX:3;

EVP_PKEY_assign_RSA; int EVP_PKEY_assign_RSA(EVP_PKEY *pkey, RSA *key); 2; 3; 0:none:3
EVP_PKEY_assign_DSA; int EVP_PKEY_assign_DSA(EVP_PKEY *pkey, DSA *key); 2; 3; 0:none:3
EVP_PKEY_assign_DH; int EVP_PKEY_assign_DH(EVP_PKEY *pkey, DH *key); 2; 3; 0:none:3
EVP_PKEY_assign_EC_KEY; int EVP_PKEY_assign_EC_KEY(EVP_PKEY *pkey, EC_KEY *key); 2; 3; 0:none:3

EVP_PKEY_set1_RSA; int EVP_PKEY_set1_RSA(EVP_PKEY *pkey, RSA *key); 2; 3; 0:none:3
EVP_PKEY_set1_DSA; int EVP_PKEY_set1_DSA(EVP_PKEY *pkey, DSA *key); 2; 3; 0:none:3
EVP_PKEY_set1_DH; int EVP_PKEY_set1_DH(EVP_PKEY *pkey, DH *key); 2; 3; 0:none:3
EVP_PKEY_set1_EC_KEY; int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey, EC_KEY *key); 2; 3; 0:none:3

# RSA key length taint
RSA_generate_key; RSA *RSA_generate_key(int num, unsigned long e, void (*callback)(int,int,void *), void *cb_arg); 4; 3; 1:bit:40;
RSA_generate_key_ex; int RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb); 4; 3; 2:bit:40;
CyaSSL_RSA_generate_key_ex; int CyaSSL_RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb); 4; 3; 2:bit:40;
EVP_PKEY_CTX_set_rsa_keygen_bits; int EVP_PKEY_CTX_set_rsa_keygen_bits(EVP_PKEY_CTX *ctx, int mbits); 2; 3; 1:CTX:3; 2:bit:40

# Cipher list for TLS/SSL usefull
SSL_CTX_set_cipher_list; int SSL_CTX_set_cipher_list(SSL_CTX *ctx, const char *str); 2; 3; 2:string:41;
SSL_set_cipher_list; int SSL_set_cipher_list(SSL *ssl, const char *str); 2; 3; 2:string:41;

SSL_CTX_set_ciphersuites; int SSL_CTX_set_ciphersuites(SSL_CTX *ctx, const char *str); 2; 3; 2:string:41;
SSL_set_ciphersuites; int SSL_set_ciphersuites(SSL *s, const char *str); 2; 3; 2:string:41;

CyaSSL_CTX_set_cipher_list; int CyaSSL_CTX_set_cipher_list(SSL_CTX *ctx, const char *str); 2; 3; 2:string:41;
wolfSSL_CTX_set_cipher_list; int wolfSSL_CTX_set_cipher_list(SSL_CTX *ctx, const char *str); 2; 3; 2:string:41;

# TLS
EVP_rc4_hmac_md5; const EVP_CIPHER *EVP_rc4_hmac_md5(void); 0; 2; 0:none:41;

# TODO (FUTURE) post rules
EVP_PKEY_CTX_ctrl; int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype, int cmd, int p1, void *p2); 6; 3; 1:CTX:1; 3:int:40; 4:int:40; 5:int:40; 6:string:40
EVP_PKEY_CTX_ctrl_str; int EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx, const char *type, const char *value); 3; 3; 2:string:40; 3:string:40;
EVP_PKEY_new_raw_private_key; EVP_PKEY *EVP_PKEY_new_raw_private_key(int type, ENGINE *e, const unsigned char *key, size_t keylen);4; 3; 3:bytes:38; 4:byte:0; 4<3;
EVP_PKEY_new_raw_public_key; EVP_PKEY *EVP_PKEY_new_raw_public_key(int type, ENGINE *e, const unsigned char *key, size_t keylen);4; 3; 3:bytes:39; 4:byte:0; 4<3;
EVP_ecdsa; const EVP_MD * EVP_ecdsa(void); 0; 3; 0:none:3

# TODO FUTURE
# CMS_EncryptedData_set1_key
#EVP_OpenFinal
#EVP_OpenInit

# OCSP x509???
# PEM_read_bio_X509
# PKCS12
# PKCS12_decrypt_skey
# RSA_PKCS1_SSLeay; RSA_METHOD * RSA_PKCS1_SSLeay(void); 1; <EXTERNAL>;cerm; (GhidraScript);PPC
# PKCS5, PKCS7,
#PKCS8_decrypt; PKCS8_PRIV_KEY_INFO * __stdcall PKCS8_decrypt(X509_SIG * p8, char * pass, int passlen); 3; none;wred; (GhidraScript);RT-AX89X
#PKCS8_encrypt; X509_SIG * __stdcall PKCS8_encrypt(int pbe_nid, EVP_CIPHER * cipher, char * pass, int passlen, uchar * salt, int saltlen, int iter, PKCS8_PRIV_KEY_INFO * p8); 3; none;wred;
#wolfSSL_CIPHER_get_name; undefined wolfSSL_CIPHER_get_name(); 2; <EXTERNAL>;cloud-client; (GhidraScript);archer-c2
#wolfSSL_X509_get_der; undefined wolfSSL_X509_get_der(); 2; <EXTERNAL>;curl; (GhidraScript);DCS-6517

# TODO (FUTURE) usage
EVP_PKEY_decrypt; int EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen, const unsigned char *in, size_t inlen); 5; 3; 4:bytes:39; 5:byte:0; 5<4;
EVP_PKEY_encrypt; int EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen, const unsigned char *in, size_t inlen); 5; 3; 4:bytes:39; 5:byte:0; 5<4;
BN_hex2bn; int BN_hex2bn(BIGNUM **a, const char *str); 2; 3; 1:CTX:3; 2:string:38
BN_set_word; int BN_set_word(BIGNUM *a, BN_ULONG w); 2; 3; 1:CTX:3; 2:int:37
BN_dec2bn;  int BN_dec2bn(BIGNUM **a, const char *str); 2; 3; 1:CTX:3; 2:string:38
# libgcrypt
gcry_sexp_build; gcry_error_t gcry_sexp_build (gcry_sexp_t *r_sexp, size_t *erroff, const char *format, ...); 3; 3; 3:string:40
gcry_sexp_new; gcry_error_t gcry_sexp_new (gcry_sexp_t *r_sexp, const void *buffer, size_t length, int autodetect); 4; 3; 2:string:40;
EC_KEY_new_by_curve_name; EC_KEY *EC_KEY_new_by_curve_name(int nid); 1; 3; 1:int:40;